<!--
 * @Descripttion: 刷题练习总结
 * @Author: ycc
 * @Date: 2022-02-11 09:37:44
 * @LastEditTime: 2022-03-31 10:22:21
-->

# 随机刷题

## 求解两数的最大公约数 - 辗转相除法

### 原理

依赖于 GCD 定理：两个整数的最大公约数等于其中较小的那个数和两数相除余数的最大公约数

## 因数分解

### 任何一个合数（因数不止是 1 和本身）都可以写成几个质数相乘的形式，这几个质数叫做这个合数的质因数

有一种使用比较广泛的算法 Pollard Rho 因数分解，并不容易理解

这里使用自己写的解法。分为两步

1. 编写 isPrime 函数，判断某数是否为质数。从 2 循环到 sqrt(num)

2. 编写 getFactor-获取因数函数，内部调用 isPrime，如果是质数，直接压入结果返回。如果不是,
   isPrime 返回因数，压入结果数组，对另一个因数递归调用 getFactor，继续分解。

## 优先使用 let，除非确定该值后续不会改变

容易出现 const 定义的值，后续改变的情况

## 链表总结

- 链表中使用虚拟头结点，可以省去判断是否为头结点还是后续节点
- 翻转链表：准备两个指针，cur 和 pre，链表翻转一个节点一个节点进行翻转即可，即将当前节点的 next 指向 pre 节点
- 链表相交
  - 注意点：链表的交点，两个节点完全相同，并不是节点值相等
  - 关键：两个链表一旦相交，说明链表最后那一段的内容一定相等。
  - 过程：所以将两个链表尾部对齐，然后从短的链表遍历，和长链表相对尾部同样位置进行对比。如果有完全相等的节点则是相交节点，如果没有则不相交。 实际实现仍然需要使用快慢指针，快指针作用于长链表，这样两者才能尾部对齐
- 删除倒数第 N 个节点

  - 思路：快慢指针法，快指针优先走 N 步，则此时还需要走 lenth-n 走完，length-n 即慢指针走过的步数，即找到了要删除的节点

- 链表两两交换相邻节点

  - 思路：准备三个指针，交换节点的第一个节点，交换节点的第二个节点，前指针，交换节点第一个节点的前节点。根据三个节点（实际上是四个，但是第二个节点的后节点可以根据 next 拿到）就能做到节点交换。交换后将三个节点重新赋值为正确的值即可。

- 环形链表：
  思路：入环节点即在链表中首个出现第二次的节点
  实现：利用哈希表结构，即 key-value 效率高于数组中查找是否存在。可以使用 Set 结构存储并判断节点是否出现了第二次

  ### 哈希表总结

  - 字母异位词：
    若 str1 和 str2 中每个字符出现的次数都相同，则称 str1 和 str2 互为字母异位词

  - 快乐数：
    1. 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和
    2. 然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1
    3. 如果这个过程 结果为 1，那么这个数就是快乐数
