<!--
 * @Descripttion: 刷题练习总结
 * @Author: ycc
 * @Date: 2022-02-11 09:37:44
 * @LastEditTime: 2022-05-09 09:40:57
-->

# 随机刷题

## 求解两数的最大公约数 - 辗转相除法

### 原理

依赖于 GCD 定理：两个整数的最大公约数等于其中较小的那个数和两数相除余数的最大公约数

## 因数分解

### 任何一个合数（因数不止是 1 和本身）都可以写成几个质数相乘的形式，这几个质数叫做这个合数的质因数

有一种使用比较广泛的算法 Pollard Rho 因数分解，并不容易理解

这里使用自己写的解法。分为两步

1. 编写 isPrime 函数，判断某数是否为质数。从 2 循环到 sqrt(num)

2. 编写 getFactor-获取因数函数，内部调用 isPrime，如果是质数，直接压入结果返回。如果不是,
   isPrime 返回因数，压入结果数组，对另一个因数递归调用 getFactor，继续分解。

## 写完后必须检查一遍

- 是否写了 return
- 如果定义了别的函数，查看额外定义的函数的 return 和传参是否正确
- 优先使用 let，const 定义的值检查后续是否有对其赋值
- 边界情况考虑
- while 循环，任何一种情况不要忘记移动指针或者改变条件，否则会死循环

## 链表总结

- 链表中使用虚拟头结点，可以省去判断是否为头结点还是后续节点
- 翻转链表：准备两个指针，cur 和 pre，链表翻转一个节点一个节点进行翻转即可，即将当前节点的 next 指向 pre 节点
- 链表相交
  - 注意点：链表的交点，两个节点完全相同，并不是节点值相等
  - 关键：两个链表一旦相交，说明链表最后那一段的内容一定相等。
  - 过程：所以将两个链表尾部对齐，然后从短的链表遍历，和长链表相对尾部同样位置进行对比。如果有完全相等的节点则是相交节点，如果没有则不相交。 实际实现仍然需要使用快慢指针，快指针作用于长链表，这样两者才能尾部对齐
- 删除倒数第 N 个节点

  - 思路：快慢指针法，快指针优先走 N 步，则此时还需要走 lenth-n 走完，length-n 即慢指针走过的步数，即找到了要删除的节点

- 链表两两交换相邻节点

  - 思路：准备三个指针，交换节点的第一个节点，交换节点的第二个节点，前指针，交换节点第一个节点的前节点。根据三个节点（实际上是四个，但是第二个节点的后节点可以根据 next 拿到）就能做到节点交换。交换后将三个节点重新赋值为正确的值即可。

- 环形链表：
  思路：入环节点即在链表中首个出现第二次的节点
  实现：利用哈希表结构，即 key-value 效率高于数组中查找是否存在。可以使用 Set 结构存储并判断节点是否出现了第二次

  ## 哈希表总结

  - 字母异位词：
    若 str1 和 str2 中每个字符出现的次数都相同，则称 str1 和 str2 互为字母异位词

  - 快乐数：

    1. 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和
    2. 然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1
    3. 如果这个过程 结果为 1，那么这个数就是快乐数

  - 三种常见的哈希结构
    1. 数组：长度固定，且可转为连续的数字下标。如题目中特意说明了只包含小写字母就是在提示使用数组哈希
    2. Set：长度未知，或者长度很大，但是使用的较少，使用数组造成空间上的极大浪费，此时使用 Set
    3. Map：Map 的使用场景和 Set 类似，知识 Set 只能存储 key，没有 Value 值。所以既要使用 Key，又要使用 Value，使用 Map

  ### 典型题目思路总结：

  - 字母异位词/赎金信：直接使用 Map 结构解题，记录出现的字母已经出现的次数即可
  - 两数之和：关键是找另一个加数。
    要求返回下标时，使用 Map 结构，循环数组，从 Map 中寻找另一个加数，未找到则压入 Map，记录 index 值。
  - 三数之和/四数之和：使用双指针法，先固定 1 位或者两位，剩余两位使用双指针法解题，该法解题的前提是数组排序
  - 四数相加：给定四个数组，要求从每个数组中任意取出一位，相加成 target，使用 Map 结构，记录两数之和的差值，然后从另外两个数组寻找。时间复杂度从 O^4 降低成 2 个 O^2

  ### 可以使用数组的结构赋值，交换数组中的两个元素

  - ` [s[left], s[right]] = [s[right], s[left]]`

  ## 字符串总结

  ### KMP 算法

  #### 前缀表

  - 前缀：不包含最后一个字符的所有以第一个字符开头的连续子串
  - 后缀：不包含第一个字符的所有以最后一个字符结尾的连续子串
  - 最长相等前后缀：所有的以第一个字符开头的连续子串中，子串的前轴和后缀最长的相等值

- 举例：

  - 文本串：aabaabaaf
  - 模式串：aabaaf
  - 前缀：a、aa、aab、aaba、aabaa
  - 后缀：f、af、aaf、baaf、abaaf
  - 最长相等前后缀
    - a：[] 0
    - aa: [[a, a]] 1
    - aab: [] 0
    - aaba: [[a, a]] 1
    - aabaa:[[a, a], [aa, aa]] 2
    - aabaaf: [] 0
      所以最长相等前后缀长度为 2，而每个位置的最长相等前后缀[0,1,0,1,2,0]，就是前缀表

- 在 aabaaf 匹配过程中，最后一个字符 f 不匹配了，那么就要在前缀表中寻找 f 前一位的相等前后缀个数，很明显是 2，下一次匹配 0 和 1 不用再匹配了，直接从 2（b）处开始匹配。这是因为前后缀相等，开头 0 和 1 的字符已经由后缀匹配过了

- next 数组：存放前缀表的数组

- 创建 next 数组（前缀表）

1. 初始化：定义 next 数组，指针 j（代表前缀的末尾位置，j+1 又是最长相等前后缀，即 push 进 next 的值）
2. 循环 s 字符串（因为前缀表就是 s 字符串每个位置的最长相等前后缀）
3. 判断 s[i] 是否等于 s[j]
4. 若相等，说明匹配成功，将当前 j 的值加 1，push 进 next 数组，当前 j 即当前的前缀末尾，表示该字符之前已经匹配了多少个字符了
5. 若不相等，则使用 while 循环，j = next[j-1]，j - 1 是去匹配冲突字符之前的前缀字符，取它的前缀表值，代表之前已经匹配过多少个字符了。然后继续 while 判断，一旦相等，就退出循环，进行第 4 步
6. 将 j push 进 next 数组

### 具体题目总结：

- 反转字符串（前后双指针调换）

  1. 利用数组 reverse 方法快速解题
  2. 定义前后双指针，交换双指针处的值，然后双指针分别向后向前移动。注意 js 的字符串无法直接利用下表修改值，先要转成数组
     交换位置可以利用数组结构赋值，不需要额外定义变量

- 反转字符串扩展：间隔 2k，前 k 个反转，后 k 个保持原来顺序

  1. 利用 slice 解题，slice 前 k 个，然后反转。再拼接后 k 个
  2. 利用 for 循环，每次循环增加 2k，然后内部判断剩余长度，将前 k 个翻转。这种做法的好处是直接在原字符串（数组）上操作，对于不需要反转的位置直接跳过处理

- replaceSpace：替换空格（数组值不影响索引）

  1. replace 快速解题
  2. 先将字符串 s 转成数组，然后判断数组每个位置的值是否等于空格，如果是则替换成 %20，再进行字符串拼接
     因为数组的值变化不影响其索引

- 颠倒字符串中的单词（快慢指针删除多余空格 + reverse 解题）

  - 注意点是先要去除多余空格，利用 trim 方法，以及快慢指针删除多余空格。
    快慢指针删除多余空格和删除数组中删除特定项其实是一样的。
  - 空格去除后利用 split 方法找出取出所有单词，将单词顺序翻转。可以利用 reverse 方法（不允许则自己实现）

- 左旋转：将字符串开头的几个字符移动到末尾

  - 利用 slice 快速解题

- 实现 strStr() ：给定原字符串和模式串，若模式串在原字符串中出现，则返回出现的位置，否则返回-1（即 indexOf）

  1. 两层循环暴力解题：即从原串的每个位置向后匹配，验证是否能匹配完模式串
  2. KMP 算法解题：求解 next 数组，循环原串，若不匹配返回 j = next[j - 1]

- 重复的子字符串，判断原串是否可以由它自身的子串重复构成

  1. 个人 repeat 解题

     1. for 循环求解所有可能的重复串（可能包含一个或多个首字母）
     2. 循环得到的重复串，判断是否可以组成原串，利用 repeat 巧妙解题

  2. KMP 算法解题
     1. 获取 next 数组
     2. 利用公式判断是否重复：数组长度 % (数组长度 - 前缀表最后一位(不为 0)) === 0

## 双指针法总结

双指针法并不隶属于某一种数据结构，但是使用比较频繁，所以单独提炼出来总结下。
双指针法最常见的是左右指针和快慢指针

具体题目总结：

- 移除元素：快慢指针经典例题

- 反转字符串：左右指针经典例题

- 翻转链表：定义当前指针和前置指针，因为翻转当前项需要直到前一项、当前项和后一项。其中后一项可以由当前项的 next
  属性获取到。所以前一项需要记录下来

- 删除链表的倒数第 N 个节点：快慢指针经典例题

  1. 快指针 先走 n 步
  2. 然后快慢指针同时在走 length - n 步，此时快指针走完，满指针指向要删除的元素
     利用 1、2 两步就把删除倒数第 n 个元素，改为删除正向数的元素，简化了题目

- 链表相交：快慢指针
  因为相交链表最后一段相同，所以尾部对齐后按顺序对比，是否由节点相同（节点在内存中同一块区域，非节点值）
  算出两个链表长度，较长的链表快指针先走长度差，然后快慢指针同时走，同时比较

- 环形链表 2：使用 Set 结构解题更快，节点是否出现了第二次

- 三数之和/四数之和：排序后使用双指针吗，比较指针值和 target 大小

## 栈与队列总结

栈的元素在内存中并不连续

### 栈题目特点：

1. 前后匹配，如{},[],<>等等
2. 消除字符串，如消除重复项，消除后还需要和前一个字符比较，每次消除总是栈顶的字符
   又比如逆波兰表达式，计算后消除栈内的数字，计算结果压入其中

3. 编译器、词法分析、文件系统（文件夹等等）

### 逆波兰表达式

- 概念：是一种后缀表达式，所谓后缀就是指算符写在后面
  - 平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) \* ( 3 + 4 )
  - 该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) \* )
- 优点：

  1. 去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + \* 也可以依据次序计算出正确结果
  2. 适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中

- 计算机：
  中缀表达式可读性强，但是对于计算机处理很不友好，计算机按顺序扫描到运算符后，不仅需要去扫面描下一个才能知道另一个运算符，而且还要考虑运算优先级，非常麻烦。而后缀表达式直接根据栈结构进行运算即可，方便很多。

### 具体题目总结

- 用栈实现队列：使用输入栈和输出栈两个栈。比使用临时栈更高效

- 用队列实现栈：队列因为其顺序的原因，通过入队和出队的操作可以循环自身。所以使用一个队列就可以实现栈了

- 有效的括号（{}、()）等匹配，栈经典例题，比如 html 模板本质上也是通过<>匹配的，遇见左括号入栈，遇见右括号出栈

- 删除字符串中的所有相邻重复项：重复项删除本质上也是匹配，删除后栈顶的项改变，有可能和后一项继续相同

  - 出栈条件：当当前项和栈顶项相同时，则出栈，并且指针向前移动以为
  - 入栈条件：栈顶和当前指针项不相同时

- 逆波兰表达式：四则运算的后缀表示法，运算数在前，符号在后

  - 入栈条件：遇见数字入栈
  - 出栈条件：遇见符号，出栈两个元素，进行符号计算后，将计算结果重新入栈
  - 注意点：
    1. 给定的数字是字符串形式，加法时要先转成数字，推荐使用使用\*1
    2. 运算符的顺序不要搞错，先 pop 出来的是第二个运算数，后 pop 出来的才是第一个运算数。减和除都和运算顺序有关
    3. 除法取整（任何区镇）时，不要使用 Math.floor，推荐使用 parseInt。Math.floor 在小数取整时实际是绝对值向上的取整
    4. 考虑使用 map 结构简化代码，key 为运算符，value 为运算函数

- 滑动窗口最大值：给你一个整数数组 nums，有一个大小为  k  的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k  个数字。滑动窗口每次只向右移动一位。
  返回 滑动窗口中的最大值

  - 思路：需要构造一个单调双向队列：单调意味着从大到小按顺序排列，双向意味着可以从尾部删除元素
  - 入队：该队列是一种特殊队列，入队时需要先从后往前，将比自己小的项向后出队，因为比自己小的项再也不可能成为最大值了，然后入队
  - 出队：需要传入出队的 value，只有在 value 等于队头时，才向前出队。这里 value 是不可能大于队头的，因为出队的是已经出现过的元素，而队列是从大到小排列的
    那么为什么不需要处理 value 小于队头的情况，该情况已在对头入队时，出队了。对头入队时会将所有小于自身的元素出队

  - 实现：
    1. 由左右指针代表窗口范围。循环前 k 项时只需要入队（窗口 size 没达到 k，无需输出最大值）
    2. 第 k 项时将队头压入 result，此时窗口长度达到 k，需要统计最大值。但是因为窗口还没有移动，不需要出队
    3. 入队并且出队，然后将对头压入 result

- 前 k 个高频元素：给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素

  - 思路：

    1. 使用 map 统计出现过的元素和个数
    2. 将 map 转为对象数组，key 和 value
    3. 将数组根据 value 大小排序
    4. 排序后的数组取长度为 k
    5. return 对象数组的 key 属性数组

  - 优先级队列做法：
    - 1、2 两步同上
    3. 自定义一个优先级队列，传入队列的除了数据还有优先级，优先级越大，越在队列前面
    4. 遍历 map，将 map 中的没个元素压入优先级队列（本质上就是在排序了）
    5. 从优先级队列中出队 k 个元素即可

## 二叉树总结

### 概念补充

- 高度和深度的区别
- 节点深度：根节点到该节点的节点个数
- 节点高度：叶子节点到该节点的节点个数
- 通俗点说：深度是上往下的层数，高度是从下往上的层数
- 层序遍历就是用来求深度的，因为是从上往下的，而无法求高度

- 所以说求高度：应该使用后序遍历：因为后序父节点最后遍历，所以递归执行到最后一层时，最先算出最下层的高度，然后递归一步一步网上回溯，高度叠加
- 求深度：应该使用先序遍历：因为父节点优先遍历，这样遍历一开始随着递归加深，从上往下叠加深度

### 递归三要素

1. 确定递归函数的参数和返回值
2. 确定终止条件
3. 确定单层递归的逻辑

### 二叉树的遍历

1. 前序遍历：先遍历父节点，父 => 左子 => 右子
2. 中序遍历：中间遍历父节点：左子 => 父 => 右子
3. 后序遍历：最后遍历父节点：左子 => 右子 => 父

- 前序、中序、后序遍历是深度优先搜索算法，因为是先一根筋走到底，然后回上去再搜索的算法。说白了就是栈结构。所以这些遍历推荐使用递归完成。使用栈结构不易理解。

4. 层序遍历：一层一层的遍历，即广度优先算法，使用队列结构完成。层序遍历能解决的问题很多，包括可以使用深度优先遍历和广度优先遍历的题，建议优先使用广度遍历即层序遍历，层序遍历无法解决时，在考虑前、中、后序遍历

层序遍历解决的题目：

- 翻转二叉树（也可使用前序、后序）：层序遍历 => 交换左右子节点
- 最大深度、最小深度：层序遍历 => 遍历到底/遍历到无左右子节点的节点的深度为止，深度即层数
- 填充节点的 next 指针，指向横向的右侧节点：层序遍历 => 指向一层中的下一个，一层中的最后一个指向 null
- 二叉树的右视图：层序遍历 => 每一层的最后一个节点

### 第二周总结

- 对称二叉树

  1. 先序遍历、后序遍历解题：一颗二叉树对称，本质上是它的左子树和右子树对称
     两颗树对称的判断：外侧相等并且内侧相等，即 left.left === right.right left.right === right.left

  2. 层序遍历：每一层都对称意味着这颗树对称，一层对称可以使用左右指针，首尾节点相等
  3. 注意点：null 和 null 也是对称，即如果一棵树最左侧为空，最右侧也为空，也是对称的

- 树的最大深度

  1. 先序遍历：先遍历父节点才是真正的求解最大深度
  2. 层序遍历：有几层深度就是多少
  3. 最大深度的判断条件，左子树和右子树种较大深度的那个

- 树的最小深度

  1. 先序遍历：和树的最大深度方法类似，但是要注意最小深度的判断条件
  2. 层序遍历：同最大深度
  3. 最小深度的终止条件和最大深度不同，最小深度的终止条件，如果左子树不存在，那么它的最小深度是右子树，如果右子树不存在，它的最小深度是左子树。如果左右子树都不存在，此时它的最小深度是 1，即它自己

- 完全二叉树的节点个数

  1. 先序遍历
  2. 层序遍历
  3. 根据完全二叉树的特点，完美二叉树它的节点个数是右公式的，判断完全二叉树是否是完美二叉树
     如果是直接个根据公式算出节点个数 2^n-1，如果不是则递归判断它的子树是否是完美二叉树。因为判断到最后叶子节点一定是完美二叉树

- 平衡树：一颗树是否平衡判断它的每个节点的左右子树高度差不超过 1，高度的定义是从最底下的叶子节点向上数的高度。深度是从最上的根节点向下数

  1. 不能使用层序遍历，层序遍历一定是从上往下，无法计算高度
  2. 需要使用后序遍历，后序遍历到底部时就能得到第一层，然后一层一层网上回，计算高度。然后计算差值。进行平衡 判断

- 二叉树的所有路径
  - 推荐使用先序遍历，父节点就是路径的前一位。然后用栈结构保存当前路径即可。每当走完一条路径，就向前回溯，就把栈顶元素出栈

### 第三周总结

- 左叶子之和：具体要知道左叶子的判断，首先它是个叶子节点，即无左右子节点，其次它是它父节点的左节点

  - 解题： 所以递归时，可以多传一个类型，表明它是父节点的左子节点还是右子节点

- 树最底层的左下角值

  1. 层序遍历，最后一层的首个元素
  2. 先序遍历，记录当前深度，一旦深度大于记录的最大深度，首先最大深度赋值为当前深度，其次记录当前节点的值为最左元素，因为先序遍历先遍历左子节点，再遍历右子节点。所以每一层遍历的第一个元素一定是最左元素，遍历第一个后，同一层其他元素遍历深度相同，不必进入该逻辑

- 路径总和：和二叉树的所有路径类似，计算总和时需要回溯
- 路径总和 2：返回等于 target 的所有路径：这里有个注意点，保存的栈（路径）必须经过浅拷贝，否则后续变化影响之前保存的路径。二叉树的所有路径那道题没问题是因为最后转成了字符串，变成了基本类型了
- 递归函数究竟什么时候需要返回值，什么时候不需要：
  当得到结果后就结束所有递归，此时需要返回值。如果有了结果还需要遍历整棵树，不需要返回值
- 二叉树的构造：利用前序与中序、利用中序与后序构造二叉树

  - 关键的理论知识：前序、中序、后序列表被正确切割后，依然是左子树和右子树的相应前、中、后序列表
  - 前序与中序，中序与后序，左侧节点的顺序是一致的，因为就差一个父节点，而父节点在前后序中被取出，用来生成当前节点了。所以切割时可以用父节点在中序节点的中的位置进行切割
  - 前序和后序不能唯一构成一棵二叉树，因为没有中序遍历就无法确定左右部分

- 二叉树：构造一棵最大的二叉树：思路和二叉树构造类似，也是递归构造当前节点，以及节点的 left 和 right 指针

### 第四周总结

- 合并二叉树：在一棵树上进行修改即可，不需要创造一颗新树，这样更简单

  1. 先序遍历合并：如果某个节点 A 有 B 没有，则该节点以及其子节点就为 A 的节点，反过来也一样
  2. 层序遍历合并：注意层序遍历没有遍历所有节点，只遍历了 A、B 都有的节点。对于 A 有 B 没有的节点不处理，因为以 A 为基础进行合并。对于 A 没有 B 有的节点，将 A 替换成 B 即可，这样一颗二叉树就合并完成了

- 二叉搜索树中寻找值为 val 的节点：二叉搜索树基础例题，根据特点进行递归查找即可

- 验证二叉搜索树：关键是直到，一颗合规的二叉搜索树，它的中序遍历应该是递增的

  1. 根据中序遍历递增，先进行中序遍历，拿到中序遍历列表，再遍历列表验证是否递增
  2. 在中序遍历的过程中验证是否递增，可以设置一个 pre 节点，通过比较 pre 和本次节点的值的大小判断是否递增

- 二叉搜索树的最小差值：和上一题类似，通过中序遍历获取排序数组

  1. 先获取中序遍历数组：然后遍历数组寻找最新小差值，即相邻两数之间的最小差值
  2. 在中序遍历过程中，根据 pre 节点，记录最小差值。如果有更小的就更新

- 二叉搜索树种的众数：众数即出现次数最多的数

  1. 普适法：求解出现次数最大：一般就是使用 Map 即哈希记录出现的元素以及出现的次数，然后比较次数的最大值，返回对应的元素即可。这道题允许最大值相等，就需要返回多个众数
  2. 二叉搜索树的特性：相等的元素必然在中序遍历中是相邻出现的，利用这个特性记录出现的次数。保存出现次数的最大值。如果新的元素出现次数大于它，则替换为新元素，如果等于它，则保留原先，并加入新元素。最终返回

- 二叉树的最近公共祖先

1.  暴力求解：先序遍历从上往下遍历每个节点，然后判断每个节点是否包含给出的两个节点，一旦包含就将结果设置为该节点。那么遍历到深度更深的祖先节点，就会更新结果。
2.  后续遍历：因为从下网上遍历，求得的祖先节点才是最近的。所以才去后序遍历。
    实际实现是先后遍历，先判断该节点是否是 p 获取 q 或者不存在，因为如果从上往下某个节点已经等于 p 了，那么没必要再去遍历它的子节点了。
    它要么只占一个节点，返回它自身（最后和另外一个组合，返回他两的祖先节点），要么占了两个节点，占两个节点时另一层必然为 null，最终就要返回它自身

### 第五周总结：二叉树完结

- 二叉搜索树的最近公共祖先：只需要前序遍历(或层序遍历，从上往下)找到一个节点 node，值 val 在 p 和 q 节点之间。有且只有一个，比它更高的祖先，不可能在这个中间，因为一定在更高祖先的一侧

  - 对比普通二叉树最近公共祖先：需要通过后续遍历从下往上查找最近祖先。并且考虑包含情况

- 二叉树的插入：比较简单，按顺序找到该节点应该插入的叶子节点插入

- 二叉树的删除：叫复杂，情况较多

  1. 删除节点不存在：什么都不做
  2. 删除节点没有子节点：直接返回 null，删除
  3. 删除节点只有 1 个子树：存在的子节点补上：node = deleteNode(node.left)
  4. 删除节点左右子树都存在：将左子树移动但右子树的最左侧，或者将右子树移动到左子树的最右侧，然后将左子树补位即可

- 二叉树的修剪（给定范围，超出则删除）：此题乍一看比删除节点还复杂，因为由可能删除多个，其实不然。因为它删除节点的同时，一定同时删除节点的左子树或者右子树，因为它不符合返回，它的左子树和右子树也一定不符合范围，实际上等同于删除节点的第三种情况，只有一个子树。相对简单

- 有序数组转为二叉搜索树：每次取有序数组的中间值，有序数组说白了就是中序遍历，中序遍历中间树即父节点，分割为左右有序数组后，继续取中间树作为左子树和右子树的父节点

- 二叉树累加：最重要搞清楚累加规则，这里是右中左的顺序累加，也可以认为时后续遍历的累加
  - 这种累加形式，要定义一个前指针，进行累加
  - 另一种想当然的累加，左子树累加、右子树累加，形成节点值，这种就可以利用后续遍历进行累加

# 回溯算法

回溯问题抽象为树形结构，可以直观的看出其搜索的过程：for 循环横向遍历，递归纵向遍历，回溯不断调整结果集

## 回溯算法总结 1

- 组合问题：
