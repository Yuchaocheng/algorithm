<!--
 * @Descripttion: 刷题练习总结
 * @Author: ycc
 * @Date: 2022-02-11 09:37:44
 * @LastEditTime: 2022-04-06 10:47:00
-->

# 随机刷题

## 求解两数的最大公约数 - 辗转相除法

### 原理

依赖于 GCD 定理：两个整数的最大公约数等于其中较小的那个数和两数相除余数的最大公约数

## 因数分解

### 任何一个合数（因数不止是 1 和本身）都可以写成几个质数相乘的形式，这几个质数叫做这个合数的质因数

有一种使用比较广泛的算法 Pollard Rho 因数分解，并不容易理解

这里使用自己写的解法。分为两步

1. 编写 isPrime 函数，判断某数是否为质数。从 2 循环到 sqrt(num)

2. 编写 getFactor-获取因数函数，内部调用 isPrime，如果是质数，直接压入结果返回。如果不是,
   isPrime 返回因数，压入结果数组，对另一个因数递归调用 getFactor，继续分解。

## 优先使用 let，除非确定该值后续不会改变

容易出现 const 定义的值，后续改变的情况

## 链表总结

- 链表中使用虚拟头结点，可以省去判断是否为头结点还是后续节点
- 翻转链表：准备两个指针，cur 和 pre，链表翻转一个节点一个节点进行翻转即可，即将当前节点的 next 指向 pre 节点
- 链表相交
  - 注意点：链表的交点，两个节点完全相同，并不是节点值相等
  - 关键：两个链表一旦相交，说明链表最后那一段的内容一定相等。
  - 过程：所以将两个链表尾部对齐，然后从短的链表遍历，和长链表相对尾部同样位置进行对比。如果有完全相等的节点则是相交节点，如果没有则不相交。 实际实现仍然需要使用快慢指针，快指针作用于长链表，这样两者才能尾部对齐
- 删除倒数第 N 个节点

  - 思路：快慢指针法，快指针优先走 N 步，则此时还需要走 lenth-n 走完，length-n 即慢指针走过的步数，即找到了要删除的节点

- 链表两两交换相邻节点

  - 思路：准备三个指针，交换节点的第一个节点，交换节点的第二个节点，前指针，交换节点第一个节点的前节点。根据三个节点（实际上是四个，但是第二个节点的后节点可以根据 next 拿到）就能做到节点交换。交换后将三个节点重新赋值为正确的值即可。

- 环形链表：
  思路：入环节点即在链表中首个出现第二次的节点
  实现：利用哈希表结构，即 key-value 效率高于数组中查找是否存在。可以使用 Set 结构存储并判断节点是否出现了第二次

  ## 哈希表总结

  - 字母异位词：
    若 str1 和 str2 中每个字符出现的次数都相同，则称 str1 和 str2 互为字母异位词

  - 快乐数：

    1. 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和
    2. 然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1
    3. 如果这个过程 结果为 1，那么这个数就是快乐数

  - 三种常见的哈希结构
    1. 数组：长度固定，且可转为连续的数字下标。如题目中特意说明了只包含小写字母就是在提示使用数组哈希
    2. Set：长度未知，或者长度很大，但是使用的较少，使用数组造成空间上的极大浪费，此时使用 Set
    3. Map：Map 的使用场景和 Set 类似，知识 Set 只能存储 key，没有 Value 值。所以既要使用 Key，又要使用 Value，使用 Map

  ### 典型题目思路总结：

  - 字母异位词/赎金信：直接使用 Map 结构解题，记录出现的字母已经出现的次数即可
  - 两数之和：关键是找另一个加数。
    要求返回下标时，使用 Map 结构，循环数组，从 Map 中寻找另一个加数，未找到则压入 Map，记录 index 值。
  - 三数之和/四数之和：使用双指针法，先固定 1 位或者两位，剩余两位使用双指针法解题，该法解题的前提是数组排序
  - 四数相加：给定四个数组，要求从每个数组中任意取出一位，相加成 target，使用 Map 结构，记录两数之和的差值，然后从另外两个数组寻找。时间复杂度从 O^4 降低成 2 个 O^2

  ### 可以使用数组的结构赋值，交换数组中的两个元素

  - ` [s[left], s[right]] = [s[right], s[left]]`
