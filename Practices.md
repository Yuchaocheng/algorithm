<!--
 * @Descripttion: 刷题练习总结
 * @Author: ycc
 * @Date: 2022-02-11 09:37:44
 * @LastEditTime: 2022-04-13 10:52:35
-->

# 随机刷题

## 求解两数的最大公约数 - 辗转相除法

### 原理

依赖于 GCD 定理：两个整数的最大公约数等于其中较小的那个数和两数相除余数的最大公约数

## 因数分解

### 任何一个合数（因数不止是 1 和本身）都可以写成几个质数相乘的形式，这几个质数叫做这个合数的质因数

有一种使用比较广泛的算法 Pollard Rho 因数分解，并不容易理解

这里使用自己写的解法。分为两步

1. 编写 isPrime 函数，判断某数是否为质数。从 2 循环到 sqrt(num)

2. 编写 getFactor-获取因数函数，内部调用 isPrime，如果是质数，直接压入结果返回。如果不是,
   isPrime 返回因数，压入结果数组，对另一个因数递归调用 getFactor，继续分解。

## 写完后必须检查一遍

- 是否写了 return
- 如果定义了别的函数，查看额外定义的函数的 return 和传参是否正确
- 优先使用 let，const 定义的值检查后续是否有对其赋值
- 边界情况考虑
- while 循环，任何一种情况不要忘记移动指针或者改变条件，否则会死循环

## 链表总结

- 链表中使用虚拟头结点，可以省去判断是否为头结点还是后续节点
- 翻转链表：准备两个指针，cur 和 pre，链表翻转一个节点一个节点进行翻转即可，即将当前节点的 next 指向 pre 节点
- 链表相交
  - 注意点：链表的交点，两个节点完全相同，并不是节点值相等
  - 关键：两个链表一旦相交，说明链表最后那一段的内容一定相等。
  - 过程：所以将两个链表尾部对齐，然后从短的链表遍历，和长链表相对尾部同样位置进行对比。如果有完全相等的节点则是相交节点，如果没有则不相交。 实际实现仍然需要使用快慢指针，快指针作用于长链表，这样两者才能尾部对齐
- 删除倒数第 N 个节点

  - 思路：快慢指针法，快指针优先走 N 步，则此时还需要走 lenth-n 走完，length-n 即慢指针走过的步数，即找到了要删除的节点

- 链表两两交换相邻节点

  - 思路：准备三个指针，交换节点的第一个节点，交换节点的第二个节点，前指针，交换节点第一个节点的前节点。根据三个节点（实际上是四个，但是第二个节点的后节点可以根据 next 拿到）就能做到节点交换。交换后将三个节点重新赋值为正确的值即可。

- 环形链表：
  思路：入环节点即在链表中首个出现第二次的节点
  实现：利用哈希表结构，即 key-value 效率高于数组中查找是否存在。可以使用 Set 结构存储并判断节点是否出现了第二次

  ## 哈希表总结

  - 字母异位词：
    若 str1 和 str2 中每个字符出现的次数都相同，则称 str1 和 str2 互为字母异位词

  - 快乐数：

    1. 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和
    2. 然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1
    3. 如果这个过程 结果为 1，那么这个数就是快乐数

  - 三种常见的哈希结构
    1. 数组：长度固定，且可转为连续的数字下标。如题目中特意说明了只包含小写字母就是在提示使用数组哈希
    2. Set：长度未知，或者长度很大，但是使用的较少，使用数组造成空间上的极大浪费，此时使用 Set
    3. Map：Map 的使用场景和 Set 类似，知识 Set 只能存储 key，没有 Value 值。所以既要使用 Key，又要使用 Value，使用 Map

  ### 典型题目思路总结：

  - 字母异位词/赎金信：直接使用 Map 结构解题，记录出现的字母已经出现的次数即可
  - 两数之和：关键是找另一个加数。
    要求返回下标时，使用 Map 结构，循环数组，从 Map 中寻找另一个加数，未找到则压入 Map，记录 index 值。
  - 三数之和/四数之和：使用双指针法，先固定 1 位或者两位，剩余两位使用双指针法解题，该法解题的前提是数组排序
  - 四数相加：给定四个数组，要求从每个数组中任意取出一位，相加成 target，使用 Map 结构，记录两数之和的差值，然后从另外两个数组寻找。时间复杂度从 O^4 降低成 2 个 O^2

  ### 可以使用数组的结构赋值，交换数组中的两个元素

  - ` [s[left], s[right]] = [s[right], s[left]]`

  ## 字符串总结

  ### KMP 算法

  #### 前缀表

  - 前缀：不包含最后一个字符的所有以第一个字符开头的连续子串
  - 后缀：不包含第一个字符的所有以最后一个字符结尾的连续子串
  - 最长相等前后缀：所有的以第一个字符开头的连续子串中，子串的前轴和后缀最长的相等值

- 举例：

  - 文本串：aabaabaaf
  - 模式串：aabaaf
  - 前缀：a、aa、aab、aaba、aabaa
  - 后缀：f、af、aaf、baaf、abaaf
  - 最长相等前后缀
    - a：[] 0
    - aa: [[a, a]] 1
    - aab: [] 0
    - aaba: [[a, a]] 1
    - aabaa:[[a, a], [aa, aa]] 2
    - aabaaf: [] 0
      所以最长相等前后缀长度为 2，而每个位置的最长相等前后缀[0,1,0,1,2,0]，就是前缀表

- 在 aabaaf 匹配过程中，最后一个字符 f 不匹配了，那么就要在前缀表中寻找 f 前一位的相等前后缀个数，很明显是 2，下一次匹配 0 和 1 不用再匹配了，直接从 2（b）处开始匹配。这是因为前后缀相等，开头 0 和 1 的字符已经由后缀匹配过了

- next 数组：存放前缀表的数组

- 创建 next 数组（前缀表）

1. 初始化：定义 next 数组，指针 j（代表前缀的末尾位置，j+1 又是最长相等前后缀，即 push 进 next 的值）
2. 循环 s 字符串（因为前缀表就是 s 字符串每个位置的最长相等前后缀）
3. 判断 s[i] 是否等于 s[j]
4. 若相等，说明匹配成功，将当前 j 的值加 1，push 进 next 数组，当前 j 即当前的前缀末尾，表示该字符之前已经匹配了多少个字符了
5. 若不相等，则使用 while 循环，j = next[j-1]，j - 1 是去匹配冲突字符之前的前缀字符，取它的前缀表值，代表之前已经匹配过多少个字符了。然后继续 while 判断，一旦相等，就退出循环，进行第 4 步
6. 将 j push 进 next 数组

### 具体题目总结：

- 反转字符串（前后双指针调换）

  1. 利用数组 reverse 方法快速解题
  2. 定义前后双指针，交换双指针处的值，然后双指针分别向后向前移动。注意 js 的字符串无法直接利用下表修改值，先要转成数组
     交换位置可以利用数组结构赋值，不需要额外定义变量

- 反转字符串扩展：间隔 2k，前 k 个反转，后 k 个保持原来顺序

  1. 利用 slice 解题，slice 前 k 个，然后反转。再拼接后 k 个
  2. 利用 for 循环，每次循环增加 2k，然后内部判断剩余长度，将前 k 个翻转。这种做法的好处是直接在原字符串（数组）上操作，对于不需要反转的位置直接跳过处理

- replaceSpace：替换空格（数组值不影响索引）

  1. replace 快速解题
  2. 先将字符串 s 转成数组，然后判断数组每个位置的值是否等于空格，如果是则替换成 %20，再进行字符串拼接
     因为数组的值变化不影响其索引

- 颠倒字符串中的单词（快慢指针删除多余空格 + reverse 解题）

  - 注意点是先要去除多余空格，利用 trim 方法，以及快慢指针删除多余空格。
    快慢指针删除多余空格和删除数组中删除特定项其实是一样的。
  - 空格去除后利用 split 方法找出取出所有单词，将单词顺序翻转。可以利用 reverse 方法（不允许则自己实现）

- 左旋转：将字符串开头的几个字符移动到末尾

  - 利用 slice 快速解题

- 实现 strStr() ：给定原字符串和模式串，若模式串在原字符串中出现，则返回出现的位置，否则返回-1（即 indexOf）

  1. 两层循环暴力解题：即从原串的每个位置向后匹配，验证是否能匹配完模式串
  2. KMP 算法解题：求解 next 数组，循环原串，若不匹配返回 j = next[j - 1]

- 重复的子字符串，判断原串是否可以由它自身的子串重复构成

  1. 个人 repeat 解题

     1. for 循环求解所有可能的重复串（可能包含一个或多个首字母）
     2. 循环得到的重复串，判断是否可以组成原串，利用 repeat 巧妙解题

  2. KMP 算法解题
     1. 获取 next 数组
     2. 利用公式判断是否重复：数组长度 % (数组长度 - 前缀表最后一位(不为 0)) === 0

## 双指针法总结

双指针法并不隶属于某一种数据结构，但是使用比较频繁，所以单独提炼出来总结下。
双指针法最常见的是左右指针和快慢指针

具体题目总结：

- 移除元素：快慢指针经典例题

- 反转字符串：左右指针经典例题

- 翻转链表：定义当前指针和前置指针，因为翻转当前项需要直到前一项、当前项和后一项。其中后一项可以由当前项的 next
  属性获取到。所以前一项需要记录下来

- 删除链表的倒数第 N 个节点：快慢指针经典例题

  1. 快指针 先走 n 步
  2. 然后快慢指针同时在走 length - n 步，此时快指针走完，满指针指向要删除的元素
     利用 1、2 两步就把删除倒数第 n 个元素，改为删除正向数的元素，简化了题目

- 链表相交：快慢指针
  因为相交链表最后一段相同，所以尾部对齐后按顺序对比，是否由节点相同（节点在内存中同一块区域，非节点值）
  算出两个链表长度，较长的链表快指针先走长度差，然后快慢指针同时走，同时比较

- 环形链表 2：使用 Set 结构解题更快，节点是否出现了第二次

- 三数之和/四数之和：排序后使用双指针吗，比较指针值和 target 大小

## 栈与队列总结

栈的元素在内存中并不连续

### 栈题目特点：

1. 前后匹配，如{},[],<>等等
2. 消除字符串，如消除重复项，消除后还需要和前一个字符比较，每次消除总是栈顶的字符
   又比如逆波兰表达式，计算后消除栈内的数字，计算结果压入其中

3. 编译器、词法分析、文件系统（文件夹等等）

### 逆波兰表达式

- 概念：是一种后缀表达式，所谓后缀就是指算符写在后面
  - 平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) \* ( 3 + 4 )
  - 该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) \* )
- 优点：

  1. 去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + \* 也可以依据次序计算出正确结果
  2. 适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中

- 计算机：
  中缀表达式可读性强，但是对于计算机处理很不友好，计算机按顺序扫描到运算符后，不仅需要去扫面描下一个才能知道另一个运算符，而且还要考虑运算优先级，非常麻烦。而后缀表达式直接根据栈结构进行运算即可，方便很多。

### 具体题目总结

- 用栈实现队列：使用输入栈和输出栈两个栈。比使用临时栈更高效

- 用队列实现栈：队列因为其顺序的原因，通过入队和出队的操作可以循环自身。所以使用一个队列就可以实现栈了

- 有效的括号（{}、()）等匹配，栈经典例题，比如 html 模板本质上也是通过<>匹配的，遇见左括号入栈，遇见右括号出栈

- 删除字符串中的所有相邻重复项：重复项删除本质上也是匹配，删除后栈顶的项改变，有可能和后一项继续相同

  - 出栈条件：当当前项和栈顶项相同时，则出栈，并且指针向前移动以为
  - 入栈条件：栈顶和当前指针项不相同时

- 逆波兰表达式：四则运算的后缀表示法，运算数在前，符号在后

  - 入栈条件：遇见数字入栈
  - 出栈条件：遇见符号，出栈两个元素，进行符号计算后，将计算结果重新入栈
  - 注意点：
    1. 给定的数字是字符串形式，加法时要先转成数字，推荐使用使用\*1
    2. 运算符的顺序不要搞错，先 pop 出来的是第二个运算数，后 pop 出来的才是第一个运算数。减和除都和运算顺序有关
    3. 除法取整（任何区镇）时，不要使用 Math.floor，推荐使用 parseInt。Math.floor 在小数取整时实际是绝对值向上的取整
    4. 考虑使用 map 结构简化代码，key 为运算符，value 为运算函数

- 滑动窗口最大值：给你一个整数数组 nums，有一个大小为  k  的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k  个数字。滑动窗口每次只向右移动一位。
  返回 滑动窗口中的最大值

  - 思路：需要构造一个单调双向队列：单调意味着从大到小按顺序排列，双向意味着可以从尾部删除元素
  - 入队：该队列是一种特殊队列，入队时需要先从后往前，将比自己小的项向后出队，因为比自己小的项再也不可能成为最大值了，然后入队
  - 出队：需要传入出队的 value，只有在 value 等于队头时，才向前出队。这里 value 是不可能大于队头的，因为出队的是已经出现过的元素，而队列是从大到小排列的
    那么为什么不需要处理 value 小于队头的情况，该情况已在对头入队时，出队了。对头入队时会将所有小于自身的元素出队

  - 实现：
    1. 由左右指针代表窗口范围。循环前 k 项时只需要入队（窗口 size 没达到 k，无需输出最大值）
    2. 第 k 项时将队头压入 result，此时窗口长度达到 k，需要统计最大值。但是因为窗口还没有移动，不需要出队
    3. 入队并且出队，然后将对头压入 result

- 前 k 个高频元素：给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素

  - 思路：

    1. 使用 map 统计出现过的元素和个数
    2. 将 map 转为对象数组，key 和 value
    3. 将数组根据 value 大小排序
    4. 排序后的数组取长度为 k
    5. return 对象数组的 key 属性数组

  - 优先级队列做法：
    - 1、2 两步同上
    3. 自定义一个优先级队列，传入队列的除了数据还有优先级，优先级越大，越在队列前面
    4. 遍历 map，将 map 中的没个元素压入优先级队列（本质上就是在排序了）
    5. 从优先级队列中出队 k 个元素即可
