<!--
 * @Descripttion: 记录js基础的通用性问题
 * @Author: ycc
 * @Date: 2022-02-12 11:19:29
 * @LastEditTime: 2022-03-17 09:54:02
-->

## Number 类型精度问题

进制转换和对阶运算（先不提，对阶运算不是很好整）会带来精度问题

我们平常见到的 x=0.1，实际是取了 toPrecision(位数)，根据 js 的 53 次方精度进行了忽略，所以 x 为 0.1

110.1010
11.1010

## JS 数据类型

基本类型：Number、String、Boolean、undefined、null、Symbol、bigInit
引用类型：function、Array、Object

bigInit 主要是用来解决超大整数的计算问题。Number 类型只能保证 2^53 - 1 内的整数计算精度，而 bigInit 则可以解决这个问题，并且进行任意大数字的计算

## JS 整数如何表示

通过 Number 类型表示，在 js 底层，所有数字都是通过 64 位浮点数来表示，所以整数也一样。

## Number() 的存储空间是多大？如果后台发送了一个超过最大可表示的数字怎么办

2 的 53 次方，即 9007199254740992，如果超过这个值，返回的结果可能会出现截断。
解决办法：可以传回字符串。如果还要进行计算，可以转为 bigInit 类型进行计算，计算完成后再通过 toString()转成字符串

## 实现函数能够深度克隆基本类型

## 事件流

三个阶段

1. 事件捕获阶段：从 window 对象传导到目标节点（上层传到底层）
2. 处于目标阶段：在目标节点上触发
3. 事件冒泡阶段：从目标节点传导回 window 对象（从底层传回上层）

- 注意：浏览器总是假定 click 事件的目标节点，就是点击位置嵌套最深的那个节点
  所以 event.target 就是最深的那个节点，而 event.currentTarget 则是设置监听的那个节点

- 可以通过设置 addEventListener 的第三个参数，设置事件是在捕获阶段触发还是冒泡阶段触发

## 事件的实现原理

- 事件实现的基本原理是发布订阅模式，首先我们预先定义事件，比如通过 addeventListen 监听某个 click 事件，这其实就是向浏览器订阅了该 click 事件，浏览器在捕捉到用户点击后，会去 emit 就是发布这个事件，内部的回调函数就会执行

web 端 Dom 事件分为几类：

1. dom 节点通过 onclick 绑定事件，这种方式的局限性就是无法给一个节点绑定多个同类型事件，绑定多个后面覆盖前面的。 并且也无法设置触发阶段
2. 通过 addEventListener 注册事件和移除事件，可以绑定多个同类型事件，并且可以设置触发阶段，即捕获阶段触发还是冒泡阶段触发
3. CSS 中的事件，比如 hover、focus 等等

## new 一个函数发生了什么

流程（结合代码理解）：

1. 创建一个以构造函数的 prototype 属性为原型的对象，比方说叫 instance `let obj=Object.create(fn.prototype)`
2. 执行构造函数，并且构造函数内部的 this 要指向刚刚构建的对象。可以使用 call 或者 apply 改变函数内部 this 的指向
3. 判断构造函数返回值，如果构造函数返回的是一个对象，new 命令返回 return 语句指定的对象，否则，就忽视 return 语句，返回 instance 对象

## symbol 有什么用处

- Symbol 类型的创建
  ` const symbol1 = Symbol(description)`

  - 创建 symbol 变量最简单的方法是用 Symbol()，Symbol 函数并不是一个构造函数，不能使用 new 关键字调用
  - Symbol()函数只有一个参数，字符串 description，这个字符串的唯一作用是辅助调试的，当我们对一个 symbol 类型 toString 的时候，输出的就是描述信息的值，注意，即使你使用 Symbol 函数创建了两个相同描述信息的 symbol，这两个 symbool 也是不相等的

- symbol 类型的特点

  1. 可以作为对象属性名，在 symbol 类型出现之前，只有字符串可以作为对象属性名
  2. symbol 的值是独一无二的，没有两个 symbol 的值会相等

- symbol 的应用

  1. 作为对象属性名可以防止重复
     这是基于以上两个特点很容易推断出来的作用，它既然可以当做对象属性名，又独一无二，自然可以作为对象属性防重名

  2. 作为类内部的私有属性

     - 其实这点也是比较容易想到的，在 class 语法中，我们比较困难在类内部创建私有变量或者说内部变量，只是用来处理类的内部逻辑而不是用来供类外部访问的
     - symbol 就可以用来处理这个问题，只要在 class 所在的 js 文件中定义一个 symbol 常量，然后定义某个属性的属性名为该 Symbol 常量，类的内部可以通过变量访问读写该属性，外部则没有办法读写
     - 当然也不是绝对没有办法，使用 Object.getOwnProperySymbols()还是可以拿到，但总体来说已经安全很多了

     - 顺便说一下，有一些提案中建议把 calss 内部#开头的变量作为私有属性，但是基本上浏览器和 Node 端都还没有兼容这种规定。那么为什么我要提一下，因为在 webpack 配置的项目中，大部分情况下可以这么写了，babel 在转化时帮助你事先了私有属性

- 内置 symbol
  JS 内部内置了一个 symbol，即 Symbol.iterator。它的值期望是一个函数，拥有 Symbol.iterator 属性的对象称为可迭代对象，即可以使用 for/fo 循环
  这里的对象是广义的对象。像数组、Map、Set 等等，都是有 iterator 属性的，而狭义的 Object 类型就不存在 iterator 属性
  当然你可以给给自己创建的对象手动添加 iterator 属性，让他支持 for of 循环，并且循环中的变量由你自己决定

## Iterator 接口 (迭代器)

Iterator 的作用：

1. 为各种数据结构，提供一个统一的、简便的访问接口
2. 使得数据结构的成员能够按某种次序排列
3. ES6 创造了一种新的遍历命令 for...of 循环，Iterator 接口主要供 for…of 使用

Iterator 的遍历过程：

1. 创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象
2. 第一次调用指针对象的 next 方法，可以将指针指向数据结构的第一个成员
3. 第二次调用指针对象的 next 方法，指针就指向数据结构的第二个成员
4. 不断调用指针对象的 next 方法，直到它指向数据结构的结束位置

每一次调用 next 方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含 value 和 done 两个属性的对象
value 属性是当前成员的值，done 属性是一个布尔值，表示遍历是否结束

### 默认 Iterator 接口

- 一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”（iterable）
- ES6 规定，默认的 Iterator 接口部署在数据结构的 Symbol.iterator 属性。即一个数据结构只要具有 Symbol.iterator 属性，就可以认为是“可遍历的”（iterable）
- Symbol.iterator 属性本身是一个函数，这个函数是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器

- 可以自定义 Symbol.iterator 函数，使得它可遍历。
  但是如果我们定义的 Symbol.iterator 不是遍历器生成函数（即会返回一个遍历器对象），forof 时浏览器报错。遍历器对象的特征就是需要具有 next 方法，每次调用 next 方法，返回 value 和 done 两个属性。for of 循环中的变量即 value 值

- 总结下，如何让一个本来不可遍历（forof）的数据结构变为可遍历的
  1. 在该结构上添加 Symbol.iterator 方法
  2. 该方法返回一个对象（遍历器对象）
  3. 这个对象上应该有 next 方法
  4. next 方法返回一个对象，对象的 value 属性值，即是 forof 中的参数值
  5. next 方法返回的 done 属性，为 ture 时代表循环结束

## 闭包是什么？

讲闭包之前要明确的概念：

### 闭包前置知识 - 作用域

概念：在 js 中，作用域即使一套规则，这套规则用来管理引擎如何在当前作用域以及嵌套的子作用域中

- 编译阶段
  编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定

- 执行阶段
  执行阶段由引擎完成，主要任务是执行可执行代码，执行上下文在这个阶段创建

# 内存空间详解

## 堆(heap)，栈(stack)与队列(queue)数据结构

- js 没有严格意义上区分栈内存与堆内存
- 一般情况是基础数据类型，在栈内存中维护，引用数据类型，在堆内存中维护

栈和队列的数据结构我已经了解，堆数据结构

- 堆数据结构是一种树状结构。它的存取数据的方式是 key-value（很像哈希表）

- 引用数据类型的值是保存在堆内存中的对象，JS 不允许直接访问堆内存中的数据，因此我们不能直接操作对象的堆内存空间。我们对对象的操作都是在操作对象的引用

## JavaScript 的内存生命周期

1. 分配你所需要的内存
2. 使用分配到的内存（读、写）
3. 不需要时将其释放、归还

- JS 有垃圾自动回收机制，那么这个机制的原理是什么呢？

- 其实很简单，就是找出那些不再继续使用的值，然后释放其占用的内存。垃圾收集器会每隔固定的时间段就执行一次释放操作

- 最常见的回收方式是通过标记清除的算法来找到哪些对象是不再继续使用的，比方说你讲一个对象赋值为 null，那么该对象指向的堆内存空间，如果没有其他变量再指向它，在下一次垃圾收集器执行时就会被释放

- 在局部作用域中，局部作用域的代码执行完毕，该变量也就没有继续存在的必要了，因为垃圾收集器很容易做出判断并回收。但是全局变量或者闭包的产生，就会让这个判断变得困难

# 执行上下文详解

- 执行上下文可以理解为函数执行的环境，每一个函数执行时，都会给对应的函数创建这样一个执行环境。所以说 js 代码执行的过程中会产生过个执行上下文，js 因为会以栈的方式来处理他们，即调用栈

- 栈底肯定是全局上下文，栈顶就是当前正在执行的执行上下文

- 执行代码时，首先将全局上下文压入执行栈，然后执行函数 X 时，将函数 X 压入执行栈，如果函数 X 中又执行函数 Y，则将 Y 压入执行栈中。当 Y 执行完毕，就将 Y 出栈，继续执行 X，X 也执行完毕，也出栈，但是全局上下只有到浏览器关闭时才会出栈

# 变量对象详解

- 问题核心：在 JS 声明的变量和函数，JS 编译器是如何找到他们的？

当一个函数被调用，一个新的执行上下文就会被创建，一个执行上下文的生命周期可以分为几个阶段

1. 创建阶段
   在这个阶段创建变量对象，确定 this 指向，以及其他需要的状态。

2. 代码执行阶段
   创建完成之后，就会开始执行代码，会完成变量赋值，以及执行其他代码

3. 销毁阶段
   可执行代码执行完毕后，执行上下文出栈，对应的内存空间失去应用，等待被回收

所以可以看出，变量对象是在执行上下文创建阶段被创建，那么变量对象的创建，又包含 3 部分：

1. 建立 arguments 对象
2. 检查当前上下文的函数声明，也就是使用 function 关键字声明的函数
   在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用
3. 检查当前上下文中的变量声明
   每找到一个变量，就在变量对象中以变量名建立一个属性，属性值为 undefined（const/let 声明的变量没有赋值，不能提前使用）

- 如果 var 变量与函数同名，则在变量对象的创建阶段（注意，该阶段还没有开始执行代码），以函数值为准，在执行阶段，函数值就会被变量值覆盖。不管变量和函数定义的先后顺序如何，最后都只保留变量值

- 进入执行阶段之前，变量对象中的属性都不能访问！ 但是进入执行阶段后，变量对象就转变为了活动对象，里面的属性都能被访问了，然后开始进行执行阶段的操作

变量对象和活动对象的区别？

- 他们其实都是同一个对象，只是处于执行上下文的不同生命周期。
- 不过只有处于函数调用栈栈顶的执行上下文中的变量对象，才会变成活动对象

- 全局上下文的变量对象
  全局上下文比较特殊，它的变量对象，就是 window 对象。this 指向也同样如此，this 指向 window
  全局上下文的声明周期，与程序的生命周期一致，只要程序运行不结束，全局上下文就会一致存在

- let const

  - 如果未定义一个变量直接调用，报错 x is not defined
  - 如果 let 定义一个变量，在这之前调用，报错 Cannot access 'x' before initialization
    这是因为第一个报错是活动对象中没有该属性，第二个报错是有该属性但是该属性完全没赋值。连 undefined 值都没有赋。即使变量提升了，也不能调用它。 这就是暂时性死区

- 总结

1.  变量对象的收集顺序， arguments -> 函数（function 定义的） -> 变量
2.  函数和变量同名时，在上下文创建阶段以函数为准，在执行阶段以变量为准
3.  变量对象在进入执行阶段后，变为活动对象
4.  let 和 const 也存在变量提升，只不过没有对其进行赋值，所以不能访问

# 怎么理解作用域与作用域链

## 作用域

- 作用域我的理解就是一块独立封闭的区域，它决定了本区域内变量或者函数的可见性
- 比方说我定义了一个函数，函数内部就行成了一个独立、封闭的函数作用域，它内部的变量无法被外部访问
- 但是一个作用域可以访问它的上级作用域。刚刚定义的函数作用域就可以访问全局作用域
- 作用域的确定是在编译阶段就确定的，换句话说，代码写完就确定了，而不是在执行时候确定

所以说作用域就像一个大的集合包含了一个小的集合，一层一层的进行包裹。在外层作用域的变量无法知道小集合内部的情况，反过来小集合内部却可以把大集合看的一清二楚

## 作用域链

- 在解释作用域的时候提到了，内部作用域可以访问外部作用域。所以这就引出了 js 变量的查找过程了
- 首先肯定是在自己的作用域下寻找变量
- 如果没找到呢，不会直接报错，因为有可能上一级作用域有
- 这里要注意，所谓的上一级作用域，是定义该函数的作用域，而不是执行该函数的作用域
- 如果还没找到，继续向上，直到找到全局作用域为止，还未找到才会报错

# 闭包是什么？

1. 闭包包含一个外部函数和一个内部函数
2. 内部函数中使用了外部函数定义的变量
3. 内部函数在外部函数以外的区域被调用了（比如把内部函数 return，或者内部函数定义为对象的属性，对象被 return 等等）

满足这三个条件，我觉得就形成了闭包

## 闭包的特点

- 最大的特点，就是内部函数使用的外部函数变量无法被释放了。对于大多数局部作用域来说，垃圾回收机制是比较容易判断出变量是否需要释放的，无非是执行时压入执行栈，执行完后出栈，函数内部变量释放。一般流程
- 但是呢外部函数因为变量被内部函数使用了，并且它有可能继续被外部调用。这就使得被使用的变量不得不一致存在内存当中，因为如果一旦释放，内部函数被调用时，无法沿着作用域链查找到外部函数定义的变量

## 闭包的应用场景

1. 需要长时间记录一个变量的场景。
   比如节流函数，我必须要知道上一次被调用的时间，这样我才能和这一次被调用的时间相比较，从而做出不同的反应。 所以就需要有一个变量记录上一次被调用的时间，而这个变量一定不能放在节流的回调里，即内部函数中，内部函数中的时间就是触发事件的时间，即当前时间，所以这个时间就在外部函数中定义了，但是在内部函数中比较，就形成了闭包
2. 模块化

# this

最重要的理解：this 的指向，是在函数被调用的时候确定的。也就是执行上下文被创建时确定的

- this 是不可赋值的，赋值就会报错

下面分四种情况，确定 this 指向

1. 全局对象中的 this - 指向 window
2. 函数中的 this
   又分两种情况：

   1. 函数独立调用，在严格模式下，内部的 this 指向 undefined，非严格模式下指向 window
   2. 函数非独立调用，即被某个对象调用，this 指向该对象

3. 构造函数中的 this 指向实例对象
   new 绑定的优先级高于 bind 显示绑定
4. DOM 监听事件中的 this 指向 DOM 本身

## JS 隐式转换，显示转换

当两个不同类型的数据进行计算时，会先转为相同类型在进行计算，这个过程是 js 自动进行的，所以称为隐式转换
所以同种类型运算是不进行隐式转换的，比如{}=={}，为 false，如果进行隐式转换，应该相等

隐式转换一般就是调用数据结构的 valueOf 方法和 toString 方法
这两个方法总的来说：

- valueOf 的作用是返回它相应的原始值
- toString 返回一个反映这个对象的字符串

Js 常见类型的 valueOf 和 toString 方法如下图所示
[!](./images//valueOf%E5%92%8CtoString.png)

隐式转换常见运算

1. ==
2. \+

### 隐式转换 —— “==”

0. 除了以下三种情况，其他都是先转为数字再做比较

1. 对象（广义对象，比如数组、Date 都可以） == 字符串 对象 -> 字符串
2. null == undefined // true
3. NaN == NaN // false

### 隐式转换 —— “+”

1. {} + 其它：不用考虑{}，Number(其他)
2. [] + 其他：+前后都转成字符串
   1、2 是特殊情况
3. 两侧有一个为字符串，则相加后的结果为字符串
4. 其他情况转为数字运算（不算对象类型）
5. 有对象类型统一转为字符运算（参考 Number）

其他运算符一律转为数字运算

### 隐式转换 Number

1. 字符串 -> 可解析就转为数字，否则为 NaN
2. BOOlean -> true 为 1，false 为 0
3. undefined -> NaN
4. null -> 0
5. 广义对象 => 优先调用 valueOf，如果不是原始类型，在调用 toString，如果还不是则报错
   这个规则解释了为什么 Object + Array 最终都会转成字符串，因为调用 valueOf 后还是对象

## bind，call，apply 具体指什么

相同点：
bind，call，apply 都是函数的方法，他们的作用是改变函数内部 this 的指向。函数内部 this 默认有它自己一套指向的规则，使用 call、apply 或者 bind 则可以强行改变

不同点：

- call 和 apply 几乎是一样的，这两个函数的唯一区别是，call 第一个参数是希望函数内部 this 指向的对象，第二个到第 n 个参数为传入函数的参数，这个区别在 ES6 出现...运算符后几乎可以忽略不计了，所以他们两者的使用场景是完全一样的

- apply 第一个参数和 call 相同，第二个参数为数组，数组元素的元素也会按顺序传入函数内部作为参数

- bind 第一个参数也是希望函数内部 this 指向的对象，第二到第 n 个参数为需要传入函数的参数。但是 bind 和 call、apply 不同的地方在于它不是立即执行的，call 和 apply 在调用时就会立即执行函数。而 bind 是生成了一个改变了函数内部 this 指向的新的函数。这在你不希望立即执行函数但又想要改变函数内部 this 指向的时候非常有用

我举一个例子，在 class 里，如果你想要增加监听事件，使用 addeventListen，对于你要传入的函数，你希望函数内部的 this 指向实例对象，但是监听事件由浏览器内部调用，里面的 this 默认指向 DOM 元素。这个时候你就可以使用 bind 强行改变内部 this，call 或 apply 则不行

### 手写 bind、apply、call

查看 this.html

## Promise

Promise 的链式调用

## 事件循环

所有的任务分为同步任务和异步任务

- 代码执行过程中遇到同步任务，直接放到主程序的执行栈栈顶执行
- 遇到异步任务（典型的有 ajax 请求、settimeout 等）放到任务队列中
- 当主程序的同步任务全部执行完毕后，会去任务队列中读取已经完成的异步任务，将这些任务推入到执行栈执行
- 这个过程不断重复就是我们说的 Event Loop 事件循环了

上面是同步任务和异步任务的角度说明事件循环，一次事件循环为一个 tick，我们还可以从宏任务和微任务的角度去分析

- 首先，宏任务包含：script(整体代码)、setTimeout、setInterval、postMessage 等，这是浏览器端，如果是 Node 环境，还包括 I/O 操作、setImmediate
- 微任务包含：Promise.then、MutationObserver（这是 H5 新增的一个监听 DOM 属性及后代节点的 API）、Node 环境下的 process.nextTick 等

知道了宏任务和微任务包含哪些东西后，就可以大致分析下一次事件循环了

1. 一次 tick 起始于宏任务，所以最早开始执行的宏任务，就是 script 标签中的代码
2. 执行过程中如果是同步任务，则直接放到执行栈执行，如果遇到微任务，就把它添加到微任务的任务队列中
3. 宏任务的同步任务执行完毕后，立即执行当前微任务队列中的所有微任务（当然是已完成的）
4. 微任务执行完毕后，本次任务执行完毕，在下一个宏任务执行之前，进行 UI 渲染
5. 渲染完毕后，继续执行下一个宏任务，从宏任务的任务队列中取
   如此循环

## onload 事件

onload 事件在资源被加载完成后会被触发

对于 script 标签，在外部 js 文件被加载后代码会被立即执行，
那么，外部 js 文件中的代码和该 script 标签的 onload 回调函数，它们的执行顺序是怎样的呢

实践证明，是在外部 js 文件被加载并执行完成后，才会触发 onload 事件

## 说一下原型和原型链

### 原型

- 关键角色

1. 构造函数
2. 实例对象
3. 原型对象

- 互相之间的关系

1. 构造函数的 prototype 属性，指向原型对象，原型对象的 constructor 属性，又反指回构造函数
2. 通过 new 关键字，调用构造函数可以生成一个实例对象，原型对象上的所有属性和方法，实例对象均可以直接访问
3. Object 对象存在方法可以让实例对象直接获取到它的原型对象（getPrototypeOf），当然**proto**也可以，但是 getPrototypeOf 是 ES6 出的标准，建议还是跟着标准来。所以说可以根据当前对象，创造一个同一个原型对象的对象
4. Object.create(null)新建的对象上是没有**proto**属性的

- 在说一点原型关于自己的理解
  先抛开原型链，之前我自己活着平时和朋友交流的时候，考虑一个问题原型比我直接给你赋值好在哪里，因为直接赋值也可以共享属性和方法
  很简单，直接赋值的方式两者完全相等，两个对象独立的个性没有办法体现。原型是把需要共享的内容放到原型对象，而你的个性又保持在实例对象上。原型对象是内存中的一块空间，实例对象又是单独分配的一块空间

### 原型链

- 因为刚刚也说了,实例对象的原型，就是构造函数创建出来的实例对象
- 那么实例对象可以去获取原型对象的属性和方法，那么这个原型对象，它既然是个对象，那么它也会有自己的原型。它的原型是什么？我们看下它是被谁创建的，因为被谁创建，原型就指向创建它的函数的 prototype 属性
- 这个原型对象 A 显然不是程序员认为创建的，那么就是 js 内部创建的，js 内部创建的对象，都是使用 Object 构造函数创建。所以原型对象 A 的原型，是 Object 函数的 prototype 属性，我们先叫他原型对象 B
- 这个原型对象 B 我们平时写的大部分对象的原型
- 这个原型对象 B，它的原型又是什么呢，它已经到顶点了，总要有个顶点的，它的原型是 null
- 所以我们看下整条链路，最顶层的 null -> Object.prototype ->你所创建的 class 的 prototype 再到 class 的实例对象，这整条链路就是原型链

原型链有什么作用？

- 原型链最大的作用，就是共享属性和方法，原型对象的属性和方法可以共享给实例对象
- 当我们再一个对象里查找一个属性的时候，首先肯定是在自身查找，找不到时再去它的原型对象查找，还没找到再去原型对象的原型对象查找，一直到 Object 的 prototype 属性上还没有找到时，认为没有该属性
- 实际应用：Vue2 中的数组类型数据变化的监听，就巧妙利用了原型链机制，重写了数组 Array 那些能够改变数组的方法，如 push、pop、shift、unshfit、reverse 等等。让在 data 中定义的数组，调用这些方法时，能够被监听到

### 原型继承

- 一个对象可以使用另外一个对象的属性或者方法，就称之为继承。所以 call 和 apply 也是继承
- 具体是通过将这个对象的原型设置为另外一个对象，这样根据原型链的规则，如果查找一个对象属性且在自身不存在时，就会查找另外一个对象，相当于一个对象可以使用另外一个对象的属性和方法了

## 说说你对 JS 的了解

JS 是一种动态类型、弱类型、基于原型的语言。

- 动态类型：执行时，变量被复制后才能确定变量的类型。相对的静态语言，编译时已经确定变量的类型了
- 弱类型：变量被定义或者说赋初始值后，在后续程序中依然可以赋一个其他类型的值，这就是弱类型

JS 严格意义上来说分为两部分：语言标准部分（ECMAScript） + 宿主环境部分

- 所谓语言标准，就是我们平时说的 ES5、ES6 等等，它里面包含了 JS 的核心语法
- 宿主环境，就是 js 能够执行的环境，在 Node 出现之前，js 只能够在浏览器中运行
- 浏览器下运行的 js，除了 ECMA 语法部分，还包括 BOM 和 DOM 部分，BOM 就是浏览器自身的一些 API，比如关于存储方面的 localStorage、sessionStorage、cookie 等；DOM 则是 DOM 操作部分
- Node 中，除了 ECMA，则是 Node 自身内置的 API，常见的文件操作、网络部分、与操作系统的交互等等

## 类数组有哪些？类数组转数组的方式

类数组：

1. nodeList
2. arguments

转数组：

1. ES6： ...运算符、Array.from
2. ES5: Array.prototype.slice.apply(arguments)，arguments 本质是一个对象，对象不存在 apply 方法，所以使用数组原型对象上的 slice 方法，利用 call 或者 apply 应用到 argumens 中

## PWA 和 serviceWorker

Webpack 学习曾经使用过，可以去回顾下，不重点复习

## 箭头函数和普通函数有啥区别？箭头函数能当构造函数吗？

主要区别：

1. 没有 this
   箭头函数自身是没有 this 的，通过查找作用域链来确定 this 的值
   注意是作用域链，而不是执行上下文。
2. 没有 arguments
   如果箭头函数的上一层还是一个函数，则会访问上一层的 arguments，如果上一层词法作用域是全局作用域，则报错，找不到 arguments
   如果想要在箭头函数中拿到参数，可以使用...扩展运算法
3. 不能通过 new 关键字调用
   - JS 函数有两个内部方法：[[Call]] 和 [[Construct]]
   - 当通过 new 调用函数时，执行 Construct 方法
   - 直接调用执行 call 方法
   - 箭头函数没有 constuctor，所以不能使用 new 调用，一旦调用就会报错
4. 没有 new.target
   new.target 返回 new 命令作用于的那个构造函数
5. 没有 prototype 属性，因为箭头函数不能使用 new，意味着它不能作为构造函数，也就没有必要保留 prototype 属性了
6. 没有 super

## 弹弹对 class 的理解，staic 关键有了解嘛？

为这个类的函数对象直接添加方法，而不是加在这个函数对象的原型对象上

## ES6 新增的 flat 方法，手写？

- 对于纯数组而言，扩展运算符一般可以使用 concat 替换
- concat 是不改变原生组的，需要重新赋值下
- flat 方法不改变原数组，生活一个新数组

## 实现函数柯里化

## 数组去重

1. Set 快速去重
2. 不使用 Set，无序去重，新建一个对象，使用 hasOwnProperty 判断是否要添加到结果数组中即可
3. 若是有序数组去重，还可以使用快慢指针

## instanceof 原理，手写 instance

1. instanceof 左边实例对象，右边传入的是 class，但是最后比较的应该是实例对象和原型对象
2. 将左边的实例对象和 class.prototype 相比较，如果不相等，则将实例对象赋值为实例对象的原型对象
3. 就这样沿着圆形脸一直对比，相等则为 true，找不到则为 false
