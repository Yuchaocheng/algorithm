# 数据结构与算法

## 线性结构

### 数组

JS 已经封装好了数组结构，比较高级。而其他常见语言数组（偏底层）一般有如下特点：

1. 不能存放不同的数据类型
2. 数组容量不会自动改变
   当超出容量时：需要进行扩容，申请一个更大容量的数组，然后将原先数组中的内容复制过去
3. 数组进行中间插入和删除操作性能比较低
   比方说头部插入一个元素，但是因为头部已经有元素了，所以需要先把所有的元素右移一位，再把新插入元素放到首位。效率较低，删除同理
4. 根据下标查找效率很高

### 栈（Stack）

数组是一个线性结构，并且可以在数组的任意位置插入和删除元素。 但是有时候，我们为了实现某些功能，必须对这种任意性加以限制。 栈和队列就是比较常见的受限的线性结构。

栈（stack）是一种运算受限的线性表，它有下特点：

1. LIFO（last in first out）：先进后出，后进先出
2. 其限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。
3. 向一个栈插入新元素又称作进栈、入栈或压栈；从一个栈删除元素又称作出栈或退栈

程序中的栈应用：

1. 函数调用栈：
   假设 A 函数中执行了 B 函数、B 函数中又执行了 C 函数
   那么在执行过程中，A 率先入栈、然后执行到 B 函数，B 函数入栈，然后 C 函数入栈。而 C 函数会优先执行完，率先出栈，然后 B 出栈，最后 A 出栈。

2. 递归：
   递归也是一种栈结构，递归函数第一遍执行，将自己入栈。然后调用自己，继续将自己压入栈中。直到达到结束递归的条件，最后一个入栈的自己执行完，再一个一个出栈。首次执行的函数，最后出栈
   如果到不了结束递归的条件，那么一直往函数调用栈入栈元素，最后导致栈溢出报错

练习：

- 有 6 个元素 6，5，4，3，2，1 按顺序进栈，问下列哪一个不是合法的出栈顺序？
  结题关键，按顺序入栈，不代表一次性全部入栈，可以入栈后，下一个元素还未入栈就出栈了

#####

#### 自定义栈

要封装一个自定义栈，首先要知道栈有哪些常见操作

- push() 添加一个新元素到栈顶位置。
- pop() 移除栈顶的元素，同时返回被移除的元素。
- peek() 返回栈顶的元素，不对栈做任何修改（该方法不会移除栈顶的元素，仅仅返回它）。
- isEmpty() 如果栈里没有任何元素就返回 true，否则返回 false。
- size() 返回栈里的元素个数。这个方法和数组的 length 属性类似。
- toString() 将栈结构的内容以字符串的形式返回。

#### 栈的应用

- 十进制转二进制

1. 整数部分：除 2 取余，反向排列
   将十进制数整数除以 2，取余数，一直除到结果为 1，余数为 0 为止
2. 小数部分：乘 2 取整，正向排列
   将十进制小数乘以 2，取整数部分，小数部分继续乘以 2，知道小数部分为 0
   这个过程中可能永远无法为 0，出现循环，表示无法完全转换，只能保留固定位数，这就是进制转换存在的精度问题

### 队列（queue）

队列（Queue）是一种运算受限的线性表，特点：先进先出。(FIFO：First In First Out)
受限之处：

1. 只允许在表的前端（front）进行删除操作
2. 只允许在表的后端（rear）进行插入操作。

应用场景：排队，比如在电影院，商场，食堂等等

#### 自定义队列

队列的实现和栈一样，有两种方案：

1. 基于数组实现
2. 基于链表实现

队列常见的操作：

1. enqueue(element) 向队列尾部添加一个（或多个）新的项
2. dequeue() 移除队列的第一（即排在队列最前面的）项，并返回被移除的元素
3. front() 返回队列中的第一个元素——最先被添加，也将是最先被移除的元素。队列不做任何变动（不移除元素，只返回元素信息与 Map 类的 peek 方法非常类似）
4. isEmpty() 如果队列中不包含任何元素，返回 true，否则返回 false
5. size() 返回队列包含的元素个数，与数组的 length 属性类似
6. toString() 将队列中的内容，转成字符串形式

#### 优先级队列

- 每个元素不再只是一个数据，还包含优先级 --所以应该是一个对象
- 在添加元素过程中，根据优先级放入到正确位置

#### 队列的应用

队列在程序中的应用：

1. 打印队列：计算机打印多个文件的时候，需要排队打印
2. 线程队列：当开启多线程时，当新开启的线程所需的资源不足时就先放入线程队列，等待 CPU 处理。

3. 击鼓传花游戏，在 main/liner/queue

优先级：
多线程时，实际每个线程可以设置他们的优先级，来决定该线程在队列中被处理的次序

### 链表

链表和数组一样，可以用于存储一系列的元素，但是链表和数组的实现机制完全不同。

数组的特点：

1. 存储多个元素，数组（或列表）可能是最常用的数据结构
2. 几乎每一种编程语言都有默认实现数组结构，提供了一个便利的 下标 语法来访问数组元素
3. 连续且固定大小的内存空间（缺点）：
   数组的创建需要申请一段连续的内存空间(一整块内存)，并且大小是固定的，当前数组不能满足容量需求时，需要扩容。 (一般情况下是申请一个更大的数组，比如 2 倍，然后将原数组中的元素复制过去)
4. 中间插入或者删除元素，效率低。
   在数组开头或中间位置插入数据的成本很高，需要进行大量元素的位移。

虽然在 js 中，数组容量也是动态增加的，并且中间插入或者删除也提供了 splice 方法，但是其底层原理还是一样的

链表的特点：

1. 不同于数组，链表中的元素在内存中不必是连续的空间
   可以充分利用计算机的内存，实现灵活的内存动态管理

2. 链表的每个元素由一个存储元素本身的节点和一个指向下一个元素的引用(有些语言称为指针)组成

3. 链表不必在创建时就确定大小，并且大小可以无限延伸下去
4. 插入删除效率高
   链表在插入和删除数据时，时间复杂度可以达到 O(1)，相对数组效率高很多
5. 访问任何一个元素时，需要从头访问，通过引用关系一个一个查找
   虽然可以轻松地到达下一个节点，但是回到前一个节点是很难的

#### 链表原理

链表的每个元素由一个存储元素本身的节点和一个指向下一个元素的引用(有些语言称为指针)组成

链表结构可以类比于火车，有一个火车头（链表的 head 属性，指向第一个节点），火车头会连接一个节点，节点上有乘客（数据），并且这个节点会连接（引用）下一个节点，以此类推

- 自定义链表
  链表中的常见操作：

1. append(element) 向链表尾部添加一个新的项。 --追加
2. insert(position, element) 向链表的特定位置插入一个新的项。 --插入
3. get(position) 获取对应位置的元素。
4. indexOf(element) 返回元素在链表中的索引。如果链表中没有该元素就返回-1。
5. update(position, element) 修改某个位置的元素。
6. removeAt(position) 从链表的特定位置移除一项。
7. remove(element) 从链表中移除一项。
8. isEmpty() 如果链表中不包含任何元素，返回 trun，如果链表长度大于 0 则返回 false。
9. size() 返回链表包含的元素个数，与数组的 length 属性类似。
10. toString() 由于链表项使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString 方法，让其只输出元素的值。

整体操作方法和数组比较类似，因为链表本身就是一种可以替代数组的结构

#### 双向链表

## 哈希表

### 哈希表理论

- 哈希表介绍
- 认识哈希化
- 地址的冲突

  - 链地址法
  - 开放地址法

- 哈希化效率

### 自定义哈希表

- 哈希函数
- 哈希表的实现
- 哈希表扩容
- 容量质数

## 树结构

### 树相关概念

- 树的基本概念
- 二叉树的概念

### 二叉搜索树

- 二叉搜索树的概念

### 树的遍历

- 中序遍历
- 先序遍历
- 后序遍历

### 二叉搜索树的删除

### 二叉树的补充

## 图结构

### 图相关概念

### 图的表示

- 邻接矩阵
- 邻接表
- 关联矩阵

### 自定义图

### 图的遍历

- 广度优先搜索
- 深度优先搜索

## 排序 & 搜索

### 简单排序

- 冒泡排序
- 选择排序

### 高级排序

- 希尔排序
- 快速排序

_XMind - Trial Version_
