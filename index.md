# 数据结构与算法

## 线性结构

- 线性结构是一个有序数据元素的集合。

- 常用的线性结构有：线性表，栈，队列，双队列，串(一维数组)。

- 常见的非线性结构有：二维数组，多维数组，广义表，树(二叉树等)，图

线性结构的特征：

1. 集合中必存在唯一的一个"第一个元素"；
2. 集合中必存在唯一的一个"最后的元素"；
3. 除最后元素之外，其它数据元素均有唯一的"后继"；
4. 除第一元素之外，其它数据元素均有唯一的"前驱"。

### 数组

JS 已经封装好了数组结构，比较高级。而其他常见语言数组（偏底层）一般有如下特点：

1. 不能存放不同的数据类型
2. 数组容量不会自动改变
   当超出容量时：需要进行扩容，申请一个更大容量的数组，然后将原先数组中的内容复制过去
3. 数组进行中间插入和删除操作性能比较低
   比方说头部插入一个元素，但是因为头部已经有元素了，所以需要先把所有的元素右移一位，再把新插入元素放到首位。效率较低，删除同理
4. 根据下标查找效率很高

### 栈（Stack）

数组是一个线性结构，并且可以在数组的任意位置插入和删除元素。 但是有时候，我们为了实现某些功能，必须对这种任意性加以限制。 栈和队列就是比较常见的受限的线性结构。

栈（stack）是一种运算受限的线性表，它有下特点：

1. LIFO（last in first out）：先进后出，后进先出
2. 其限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。
3. 向一个栈插入新元素又称作进栈、入栈或压栈；从一个栈删除元素又称作出栈或退栈

程序中的栈应用：

1. 函数调用栈：
   假设 A 函数中执行了 B 函数、B 函数中又执行了 C 函数
   那么在执行过程中，A 率先入栈、然后执行到 B 函数，B 函数入栈，然后 C 函数入栈。而 C 函数会优先执行完，率先出栈，然后 B 出栈，最后 A 出栈。

2. 递归：
   递归也是一种栈结构，递归函数第一遍执行，将自己入栈。然后调用自己，继续将自己压入栈中。直到达到结束递归的条件，最后一个入栈的自己执行完，再一个一个出栈。首次执行的函数，最后出栈
   如果到不了结束递归的条件，那么一直往函数调用栈入栈元素，最后导致栈溢出报错

练习：

- 有 6 个元素 6，5，4，3，2，1 按顺序进栈，问下列哪一个不是合法的出栈顺序？
  结题关键，按顺序入栈，不代表一次性全部入栈，可以入栈后，下一个元素还未入栈就出栈了

#####

#### 自定义栈

要封装一个自定义栈，首先要知道栈有哪些常见操作

- push() 添加一个新元素到栈顶位置。
- pop() 移除栈顶的元素，同时返回被移除的元素。
- peek() 返回栈顶的元素，不对栈做任何修改（该方法不会移除栈顶的元素，仅仅返回它）。
- isEmpty() 如果栈里没有任何元素就返回 true，否则返回 false。
- size() 返回栈里的元素个数。这个方法和数组的 length 属性类似。
- toString() 将栈结构的内容以字符串的形式返回。

#### 栈的应用

- 十进制转二进制

1. 整数部分：除 2 取余，反向排列
   将十进制数整数除以 2，取余数，一直除到结果为 1，余数为 0 为止
2. 小数部分：乘 2 取整，正向排列
   将十进制小数乘以 2，取整数部分，小数部分继续乘以 2，知道小数部分为 0
   这个过程中可能永远无法为 0，出现循环，表示无法完全转换，只能保留固定位数，这就是进制转换存在的精度问题

### 队列（queue）

队列（Queue）是一种运算受限的线性表，特点：先进先出。(FIFO：First In First Out)
受限之处：

1. 只允许在表的前端（front）进行删除操作
2. 只允许在表的后端（rear）进行插入操作。

应用场景：排队，比如在电影院，商场，食堂等等

#### 自定义队列

队列的实现和栈一样，有两种方案：

1. 基于数组实现
2. 基于链表实现

队列常见的操作：

1. enqueue(element) 向队列尾部添加一个（或多个）新的项
2. dequeue() 移除队列的第一（即排在队列最前面的）项，并返回被移除的元素
3. front() 返回队列中的第一个元素——最先被添加，也将是最先被移除的元素。队列不做任何变动（不移除元素，只返回元素信息与 Map 类的 peek 方法非常类似）
4. isEmpty() 如果队列中不包含任何元素，返回 true，否则返回 false
5. size() 返回队列包含的元素个数，与数组的 length 属性类似
6. toString() 将队列中的内容，转成字符串形式

#### 优先级队列

- 每个元素不再只是一个数据，还包含优先级 --所以应该是一个对象
- 在添加元素过程中，根据优先级放入到正确位置

#### 队列的应用

队列在程序中的应用：

1. 打印队列：计算机打印多个文件的时候，需要排队打印
2. 线程队列：当开启多线程时，当新开启的线程所需的资源不足时就先放入线程队列，等待 CPU 处理。

3. 击鼓传花游戏，在 main/liner/queue

优先级：
多线程时，实际每个线程可以设置他们的优先级，来决定该线程在队列中被处理的次序

### 链表

链表和数组一样，可以用于存储一系列的元素，但是链表和数组的实现机制完全不同。

数组的特点：

1. 存储多个元素，数组（或列表）可能是最常用的数据结构
2. 几乎每一种编程语言都有默认实现数组结构，提供了一个便利的 下标 语法来访问数组元素
3. 连续且固定大小的内存空间（缺点）：
   数组的创建需要申请一段连续的内存空间(一整块内存)，并且大小是固定的，当前数组不能满足容量需求时，需要扩容。 (一般情况下是申请一个更大的数组，比如 2 倍，然后将原数组中的元素复制过去)
4. 中间插入或者删除元素，效率低。
   在数组开头或中间位置插入数据的成本很高，需要进行大量元素的位移。

虽然在 js 中，数组容量也是动态增加的，并且中间插入或者删除也提供了 splice 方法，但是其底层原理还是一样的

链表的特点：

1. 不同于数组，链表中的元素在内存中不必是连续的空间
   可以充分利用计算机的内存，实现灵活的内存动态管理

2. 链表的每个元素由一个存储元素本身的节点和一个指向下一个元素的引用(有些语言称为指针)组成

3. 链表不必在创建时就确定大小，并且大小可以无限延伸下去
4. 插入删除效率高
   链表在插入和删除数据时，时间复杂度可以达到 O(1)，相对数组效率高很多
5. 访问任何一个元素时，需要从头访问，通过引用关系一个一个查找
   虽然可以轻松地到达下一个节点，但是回到前一个节点是很难的

#### 链表原理

链表的每个元素由一个存储元素本身的节点和一个指向下一个元素的引用(有些语言称为指针)组成

链表结构可以类比于火车，有一个火车头（链表的 head 属性，指向第一个节点），火车头会连接一个节点，节点上有乘客（数据），并且这个节点会连接（引用）下一个节点，以此类推

#### 自定义链表

链表中的常见操作：

1. append(element) 向链表尾部添加一个新的项。 --追加
2. insert(position, element) 向链表的特定位置插入一个新的项。 --插入
3. get(position) 获取对应位置的元素。
4. indexOf(element) 返回元素在链表中的索引。如果链表中没有该元素就返回-1。
5. update(position, element) 修改某个位置的元素。
6. removeAt(position) 从链表的特定位置移除一项。
7. remove(element) 从链表中移除一项。
8. isEmpty() 如果链表中不包含任何元素，返回 trun，如果链表长度大于 0 则返回 false。
9. size() 返回链表包含的元素个数，与数组的 length 属性类似。
10. toString() 由于链表项使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString 方法，让其只输出元素的值。

整体操作方法和数组比较类似，因为链表本身就是一种可以替代数组的结构

#### 双向链表

- 单向链表特点

  1. 只能从头遍历到尾或者从尾遍历到头（一般从头到尾）
  2. 链表相连的过程是单向的，实现原理是上一个节点中有指向下一个节点的引用
  3. 单向链表有一个比较明显的缺点：可以轻松到达下一个节点，但回到前一个节点很难，在实际开发中, 经常会遇到需要回到上一个节点的情况

- 双向链表特点
  1. 既可以从头遍历到尾，也可以从尾遍历到头
  2. 链表相连的过程是双向的。实现原理是一个节点既有向前连接的引用，也有一个向后连接的引用
  3. 双向链表可以有效的解决单向链表存在的问题，即回到上一个节点
  4. 双向链表缺点
     每次在插入或删除某个节点时，都需要处理四个引用，而不是两个，实现起来会困难些？
     相对于单向链表，所占内存空间更大一些

但是，相对于双向链表的便利性而言，这些缺点微不足道。所以它在各种语言中的应用比单向链表要多。

- 双向链表结构：

  1. 双向链表不仅有 head 指针指向第一个节点，而且有 tail 指针指向最后一个节点，还有一个 length
  2. 每一个节点由三部分组成：item 储存数据、prev 指向前一个节点、next 指向后一个节点
  3. 双向链表的第一个节点的 prev 指向 null
  4. 双向链表的最后一个节点的 next 指向 null

- 双向链表常见的操作

  1. append(element) 向链表尾部追加一个新元素
  2. insert(position, element) 向链表的指定位置插入一个新元素
  3. getElement(position) 获取指定位置的元素
  4. indexOf(element) 返回元素在链表中的索引。如果链表中没有该元素就返回 -1
  5. update(position, element) 修改指定位置上的元素
  6. removeAt(position) 从链表中的删除指定位置的元素
  7. remove(element) 从链表删除指定的元素
  8. isEmpty() 如果链表中不包含任何元素，返回 trun，如果链表长度大于 0 则返回 false
  9. size() 返回链表包含的元素个数，与数组的 length 属性类似
  10. toString() 由于链表项使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString 方法，让其只输出元素的值
  11. forwardString() 返回反向遍历节点字符串形式，forward 代表从后往前
  12. backwardString() 返回正向遍历的节点的字符串形式，backward 代表从前往后，和 toString 完全相同
  13. getHead() 获取首部元素
  14. getTail() 获取尾部元素

## 集合

几乎每种编程语言中，都有集合结构。集合比较常见的实现方式是哈希表，这里使用 JavaScript 的 Object 进行封装。

### 集合的特点

- 集合通常是由一组无序的、不能重复的元素构成
- 数学中常指的集合中的元素是可以重复的，但是计算机中集合的元素不能重复
- 集合可以看做是特殊的数组：
  1. 特殊之处在于里面的元素没有顺序，也不能重复
  2. 没有顺序意味着不能通过下标值进行访问，不能重复意味着相同的对象在集合中只会存在一份

### 封装集合

ES6 中的 Set 就是一个集合类，这里我们重新封装一个 Set 类，了解集合的底层实现

### 集合常见的操作

1. add(value) 向集合添加一个新的项
2. delete(value) 从集合移除一个值 --教程中是 remove 方法，这里和 ES6 的 Set 类保持一致，有利于记忆
3. has(value) 如果值在集合中，返回 true，否则返回 false
4. clear() 移除集合中的所有项
5. size() 返回集合所包含元素的数量。与数组的 length 属性类似
6. values() 返回一个包含集合中所有值的数组

还有其他的方法，用的不多，这里不做封装。

### 集合间的操作

- 并集（代表合并）：对于给定的两个集合，返回一个包含两个集合中所有元素的新集合
  A∪B = {x|x∈A,或 x∈B}
- 交集（代表相交）：对于给定的两个集合，返回一个包含两个集合中共有元素的新集合
  A∩B= {x|x∈A∧x∈B}
- 差集（代表差值，即相减）：对于给定的两个集合，返回一个包含所有存在于第一个集合且不存在于第二个集合的元素的新集合
  A - B
- 子集：验证一个给定集合是否是另一个集合的子集。集合 A 的任意一个元素都是集合 B 的元素
  A⊆B

## 字典

数组-集合-字典是几乎编程语言都会默认提供的数据类型。ES6 新增了 Map 类型，就是代表字典。

### 字典的特点

- 字典存储的是键值对，主要特点是一一对应。
- 比如保存一个人的信息
  1. 数组形式：[19，"Tom", 1.65]，可通过下标值取出信息。
  2. 字典形式：{"age": 19, "name": "Tom", "height": 165}，可以通过 key 取出 value
- 此外，在字典中 key 是不能重复且无序的，而 Value 可以重复

有些编程语言中称这种映射关系为字典，如 Swift 中的 Dictonary，Python 中的 dict
有些编程语言中称这种映射关系为 Map，比如 Java 中的 HashMap 和 TreeMap 等

### 字典的常见操作

1. set(key,value) 向字典中添加新元素
2. remove(key) 通过使用键值来从字典中移除键值对应的数据值
3. has(key) 如果某个键值存在于这个字典中，则返回 true，反之则返回 false
4. get(key) 通过键值查找特定的数值并返回
5. clear() 将这个字典中的所有元素全部删除
6. size() 返回字典所包含元素的数量。与数组的 length 属性类似
7. keys() 将字典所包含的所有键名以数组形式返回
8. values() 将字典所包含的所有数值以数组形式返回

## 哈希表

### 哈希表理论

#### 哈希表介绍

哈希表是一种非常重要的数据结构，几乎所有的编程语言都直接或者间接应用这种数据结构

- 哈希表通常是基于数组实现的，但是相对于数组，它存在更多优势：

  1.  哈希表可以提供非常快速的 插入-删除-查找 操作
  2.  无论多少数据，插入和删除值都只需接近常量的时间，即 O(1) 的时间复杂度。实际上，只需要几个机器指令 即可完成
  3.  哈希表的速度比树还要快，基本可以瞬间查找到想要的元素
  4.  哈希表相对于树来说编码要简单得多

- 哈希表同样存在不足之处：
  1.  哈希表中的数据是没有顺序的，所以不能以一种固定的方式（比如从小到大 ）来遍历其中的元素
  2.  通常情况下，哈希表中的 key 是不允许重复的，不能放置相同的 key，用于保存不同的元素

哈希表无序且不能重复的特点，所以集合和字典都是基于哈希表实现

- 哈希表是什么？
  1.  哈希表并不好理解，不像数组、链表和树等可通过图形的形式表示其结构和原理
  2.  哈希表的结构就是数组，但它神奇之处在于对下标值的一种变换，这种变换我们可以称之为哈希函数，通过哈希函数可以获取 HashCode

接下来就通过几个案例了解下哈希表

- 案例一：公司想要存储 1000 个人的信息，每一个工号对应一个员工的信息

  1.  数组
      当中间有人离职和入职时，插入新员工和删除旧员工信息的效率较低。
      通过名字查找对应人员的效率较低（遍历）。
      通过工号查找效率较高（工号从 0 开始++），即为下标。通过下标查找
  2.  链表
      员工信息的应用场景大多还是在查找。链表查找效率很低，需要从头或者从尾遍历
      链表的优势在于插入和删除较快，但是员工的变动并不会太频繁
  3.  哈希表
      数组通过工号查找效率较高。通过名字查找则不行
      哈希函数就是将某个 key 和索引值对应起来，这样通过名称我就能知道工号，再通过工号查找效率就很高了

- 案例二：存储联系人和对应的电话号码

  1. 数组 or 链表：
     还是同样的问题，一般查找都是根据联系人姓名查找电话号码。数组或者链表的形式，查找时就需要遍历，当数据量很大时效率低
  2. 哈希表
     基于数组，但是在联系人姓名和下标之间建议对应关系。即将字符串转成下标值的方法（哈希函数）

- 案例三：50000 个单词的存储
  和案例二类似，通过单词本身查找时需要遍历。最好是通过哈希函数，通过单词查找到下标，再通过下标查找
  效率大大提高

案例总结：哈希表最后还是基于数组来实现的，只不过哈希表能够通过哈希函数把字符串转化为对应的下标值，建立字符串和下标值的映射关系。

#### 认识哈希化

- 单词转数字
  首先为了演示，自己创造一套编码，a-c 为 1-26
  1. 数字相加：将单词每个词的编码相加
     致命的问题是很容易造成下标重复，不同的单词相加可能得到相同的数字
  2. 幂的连乘
     假设有一个数 6357 可以表示为 6*10^3 + 3*10^2 + 5*10^1 + 7*10^0
     那么编码相乘也一样，27 即所有的编码数：比如 cats = 3*27^3 + 1*27^2 + 20\*27^1 + 17
     幂的连乘可以保证唯一性
     但是创建了太大数字的下标了，造成数组的长度很大，内部很多无效单词，耗费内存

两种方案总结：第一种方案（让数字相加求和）产生的数组下标太少。第二种方案（与 27 的幂相乘求和）产生的数组下标又太多。

- 现在需要一种压缩方法，把幂的连乘方案系统中得到的巨大整数范围压缩到可接受的数组范围中。
  可以通过取余操作来实现
  虽然取余操作得到的结构也有可能重复，但重复数量大大减少，并且可以通过其他方式解决。

- 哈希化：
  将大数字转化成数组范围内下标的过程，称之为哈希化

- 哈希函数
  我们通常会将单词转化成大数字，把大数字进行哈希化的代码实现放在一个函数中，该函数就称为哈希函数

- 哈希表
  对最终数据插入的数组进行整个结构的封装，得到的就是哈希表，即已经对数组进行改良过的数据结构

#### 地址的冲突

在实际压缩时，经过哈希函数哈希化过后得到的下标值可能有重复，这种情况称为冲突，冲突是不可避免的，我们只能解决冲突。

- 比如将 0-199 的数字选取 5 个放在长度为 10 的单元格中，利用取余算法
  如果选取出来的数字对 10 取余后没有重复，则没问题
  如果有重复的则代表了地址冲突

解决冲突常见的两种方案：链地址法（拉链法）和开放地址法。

##### 链地址法（拉链法）

- 概念： 取余压缩，余数重复数据以数组或链表结构存储在根数组中
  将每一个数字都对 10 进行取余操作，则余数的范围 0~9 作为数组的下标值。
  并且，数组每一个下标值对应的位置存储的不再是一个数字了，而是存储由经过取余操作后得到相同余数的数字组成的数组或链表

在哈希表数组中，每一项在存放数组或者链表效率相当。因为重复的元素一般是不会太多的。
可根据业务决定，如果是往头部插入的，建议还是使用数组。 往头部插入一般是认为新插入的项使用频率高

##### 开放地址法

- 工作方式：寻找空白的单元格来添加重复的数据 （这个也是我第一时间想到的思路）

如何寻找空白单元格，一般有三种方式线性探测、二次探测、再哈希化

###### 线性探测

- 概念：线性的查找空白单元，比如下标+1

- 插入后如何查找？
  首先查找余数的位置，取出数据后和自身对比，相同查找完毕，如果不相同就继续线性向后查找
  查询过程中不会遍历整个哈希表，只要查询到空位置，就停止，因为插入 13 时不会跳过空位置去插入其他位置。
  如果查找到空位置还没有找到，说明哈希表中没有该元素

- 插入后如何删除？
  删除操作和上述两种情况类似，首先是和，但需要注意的是，删除一个数据项时，不能将该位置下标的内容设置为 null，否则会影响到之后其他的查询操作，因为一遇到为 null 的位置就会停止查找
  通常删除一个位置的数据项时，我们可以将它进行特殊处理（比如设置为-1），这样在查找时遇到-1 就知道要继续查找。

- 线性探测存在的问题：
  1.  线性探测存在一个比较严重的问题，就是聚集
      如哈希表中还没插入任何元素时，插入 23、24、25、26、27，这就意味着下标值为 3、4、5、6、7 的位置都放置了数据，这种一连串填充单元就称为聚集
      聚集会影响哈希表的性能，无论是插入/查询/删除都会影响
      比如插入 13 时就会发现，连续的单元 3~7 都不允许插入数据，并且在插入的过程中需要经历多次这种情况。二次探测法可以解决该问题

##### 二次探测

- 概念：优化步长，不再每次加 1，而是+步长的平方

线性探测存在问题：如果之前的数据是连续插入的，那么新插入的一个数据可能需要探测很长的距离；

- 二次探测是在线性探测的基础上进行了优化：
  对步长进行了优化，比如从下标值 x 开始探测：x+1^2、x+2^2、x+3^2。这样一次性探测比较长的距离，避免了数据聚集带来的影响。

- 二次探测的步长是固定的，1,4,9,16 。。。。

- 二次探测存在的问题：
  当插入数据分布性较大的一组数据时，比如：5,6,,9,14，这种情况会造成步长不一的一种聚集
  当然实际开发时，这种情况的可能性比线性探测小很多，有没有办法彻底解决聚集问题呢？

再哈希法彻可以解决聚集问题

##### 再哈希化

在开放地址法中寻找空白单元格的最好的解决方式为再哈希化。

- 不管是线性探测还是二次探测他们的问题就是每个数据的步长一致。
  所以现在需要一种方法：产生一种依赖关键字(数据)的探测序列，不同的关键字即使映射到相同的数组下标，也可以使用不同的探测序列

- 再哈希化概念：
  把关键字用另一个哈希函数，再做一次哈希化，用这次哈希化的结果作为该关键字的步长
- 第二次哈希化需要满足以下两点：

  1. 和第一个哈希函数不同，不然哈希化后的结果仍是原来位置（即首次哈希化相同的元素步长又相同了）
  2. 不能输出为 0，否则每次探测都是原地踏步的死循环（为 0 的话每次都有数据，就会继续查找）

- 已有的优秀哈希函数（计算步长）：
  stepSize = constant - （key % constant）；
  其中 constant 是质数，且小于数组的容量

#### 哈希化效率

哈希表中执行插入和搜索操作效率是非常高的

- 如果没有发生冲突，那么效率就会更高
- 如果发生冲突，存取时间就依赖后来的探测长度
- 平均探测长度以及平均存取时间，取决于填装因子，随着填装因子变大，探测长度会越来越长

填装因子(LoadFactor)

- 装填因子表示当前哈希表中已经包含的数据项和整个哈希表长度的比值
- 装填因子 = 总数据项 / 哈希表长度
- 开放地址法的装填因子最大为 1，因为只有空白的单元才能放入元素
- 链地址法的装填因子可以大于 1，因为只要愿意，拉链法可以无限延伸下去

不同探测方式性能的比较

- 线性探测
  随着装填因子的增大，平均探测长度呈指数形式增长，性能较差

- 二次探测和再哈希化的性能
  二次探测和再哈希法性能相当，它们的性能比线性探测略好，但总体来说性能也一般。随着装填因子的变大，平均探测长度呈指数形式增长
  都是呈指数增长，但是二次探测或再哈希法装填因子在 0.7 左右才开始指数增长，前面增长缓慢
  而线性增长在 0.4 左右就开始呈指数上升

- 链地址法的性能
  可以看到随着装填因子的增加，平均探测长度呈线性增长，较为平缓，平均性能较好。
  在开发中使用链地址法较多，比如 Java 中的 HashMap 中使用的就是链地址法。

### 自定义哈希表

#### 哈希函数

哈希表的优势在于它的速度，所以哈希函数不能采用消耗性能较高的复杂算法。提高速度的一个方法是在哈希函数中尽量减少乘法和除法

性能高的哈希函数应具备以下两个优点：

1. 快速的计算
2. 均匀的分布
   均匀分布意味着应竟可能让元素映射到数组中不同的项，减少地址冲突。
   因为当多个元素映射到同一个位置时，查找效率就会变低

##### 快速计算 - 霍纳法则

![](./images/霍纳法则.png)

- 求多项式的值时，首先计算最内层括号内一次多项式的值，然后由内向外逐层计算一次多项式的值。这种算法 - 把求 n 次多项式 f(x)的值就转化为求 n 个一次多项 - 式的值。

- 变换之前：
  乘法次数：n(n+1)/2 次
  加法次数：n 次
- 变换之后：
  乘法次数：n 次
  加法次数：n 次

如果使用大 O 表示时间复杂度的话，直接从变换前的 O(N^2)降到了 O(N)

##### 均匀分布

- 在设计哈希表时，我们已经有办法处理映射到相同下标值的情况：链地址法或者开放地址法。但是，为了提供效率，最好的情况还是让数据在哈希表中均匀分布。因此，我们需要在使用常量的地方，尽量使用质数。比如：哈希表的长度、N 次幂的底数等

- Java 中的 HashMap 采用的是链地址法，哈希化采用的是公式为：index = HashCode(key) & (Length-1) 即将数据化为二进制进行与运算，而不是取余运算。这样计算机直接运算二进制数据，效率更高。但是 JavaScript 在进行较大数据的与运算时会出现问题，所以我们使用 JavaScript 实现哈希化时采用取余运算

#### 哈希表的实现

##### 哈希表常见操作

- put(key, value) 插入或修改操作。
- get(key) 获取哈希表中特定位置的元素。
- remove(key) 删除哈希表中特定位置的元素。
- isEmpty() 如果哈希表中不包含任何元素，返回 trun，如果哈希表长度大于 0 则返回 false。
- size() 返回哈希表包含的元素个数。
- resize(value) 对哈希表进行扩容或压缩操作

#### 哈希表扩容

- 为什么需要扩容？

  - 由于封装的哈希表使用的是链地址法，装填因子(loadFactor)可以大于 1，所以这个哈希表可以无限制地插入新数据
  - 但是，随着数据量的增多，storage 中每一个 index 对应的 bucket 数组（链表）就会越来越长， 而 bucket 数组是线性查找，这就会造成哈希表效率的降低

- 什么情况下需要扩容或者压缩容量？
  常见的情况是 loadFactor > 0.75 的时候进行扩容； loadFactor < 0.25 进行压缩

- 如何进行扩容？
  - 简单的扩容可以直接扩大（缩小）两倍（关于质数，之后讨论）
  - 扩容之后所有的数据项都要进行同步修改，原因是容量变化后，对容量取余的结果会不同，所以数据再哈希表中的排布改变。所有的数据项必须根据当前容量重新添加。

#### 容量质数

- 质数的判断

- 扩容或者锁容时，寻找邻近的质数，使用 isPrime 循环，num++ 即可实现

## 树结构

各数据结构优劣势对比，使用场景分析。 这个最后的时候总结一波，在视频 P78。如果忘了可以追溯

- 树（Tree）：由 n（n ≥ 0）个节点构成的有限集合。当 n = 0 时，称为空树

- 对于任意一棵非空树（n > 0），它具备以下性质：

  - 数中有一个称为根（Root）的特殊节点，用 r 表示
  - 其余节点可分为 m（m > 0）个互不相交的有限集合 T1，T2，...，Tm，其中每个集合本身又是一棵树，称为原来树的子树（SubTree）

### 树相关概念

#### 树的基本概念

- 树的常用术语：

  1. 节点的度（Degree）：节点的子树个数
  2. 树的度：树的所有节点中最大的度数
  3. 叶节点（Leaf）：度为 0 的节点（也称为叶子节点）
  4. 父节点（Parent）：度不为 0 的节点称为父节点
  5. 子节点（Child）：若 B 是 D 的父节点，那么 D 就是 B 的子节点
  6. 兄弟节点（Sibling）：具有同一父节点的各节点彼此是兄弟节点
  7. 路径和路径长度：路径指的是一个节点到另一节点的通道，路径所包含边(链路)的个数称为路径长度
  8. 节点的层次（Level）：规定根节点在 1 层，其他任一节点的层数是其父节点的层数加 1
  9. 树的深度（Depth）：树种所有节点中的最大层次是这棵树的深度

- 树结构的表示方法

  1. 常规表示方法：：
     ![](./images/数结构常规表示法.png)
     如图，树结构的组成方式类似于链表，都是由一个个节点连接构成。不过，根据每个父节点子节点数量的不同，每一个父节点需要的引用数量也不同。
     这种方法缺点在于我们无法确定某一结点的引用数。造成每一个节点的内部属性不好确定。如果使用嵌套数组，会造成树的复杂度上升

  2. 儿子-兄弟表示法：
     ![](./images/树结构儿子兄弟表示法.png)

     - 这种表示法的优点在于每一个节点中引用的数量都是确定的
     - 这种表示法的本质，父节点只连接一个子节点 B，其他的子节点如 C，通过 B 的兄弟属性相连接，这里要注意了，一旦 B 指向了 C，C 实际上成为了 B 的子节点
     - 所以儿子-兄弟表示法，子节点有两种类型，第一种是在常规表示法的子节点中取一个，另外一个子节点是常规表示法的兄弟节点。
     - 如此转换后，这棵普通的树，转变为了二叉树

  儿子-兄弟表示法，节点可存储为如下结构

  ```js
  //节点A
     Node{
       //存储数据
       this.data = data
       //统一只记录左边的子节点
       this.leftChild = B
       //统一只记录右边的第一个兄弟节点
       this.rightSibling = null
     }

     //节点B
     Node{
       this.data = data
       this.leftChild = E
       this.rightSibling = C
     }

     //节点F
     Node{
       this.data = data
       this.leftChild = null
       this.rightSibling = null
     }
  ```

结论： 任何树都可以通过二叉树进行模拟。
父子节点的关系可能会被改变。但是父节点的设置只是为了方便指向子节点，在代码实现中谁是父节点并没有关系，只要能正确找到对应节点即可

#### 二叉树的概念

- 概念： 如果树中的每一个节点最多只有两个子节点，这样的树就称为二叉树
- 组成：
  - 二叉树可以为空，也就是没有节点
  - 若二叉树不为空，则它由根节点和称为其左子树 TL 和右子树 TR 的两个不相交的二叉树组成
- 五种形态：

  1. 空的二叉树
  2. 只有一个节点的二叉树
  3. 只有左子树 TL 的二叉树
  4. 有右子树 TR 的二叉树
  5. 有左右两个子树的二叉树

- 重要的特性（笔试题常见）：

  1. 一个二叉树的第 i 层的最大节点树为：2^(i-1)，i >= 1
     这个比较好理解，第一层（根）为 1，第二层为 1\*2，第三层为 2 乘 2，因为下一层永远是对上一层 每一个节点分叉出 2 个，是上一层的两倍

  2. 深度为 k 的二叉树的最大节点总数为：2^k - 1 ，k >= 1
     这个也好理解，2^0+2^1+2^2... + 2^n-1 = 2^n - 1
     因为前面最后一层刚好比前面所有层次加起来大 1，所以再加 1，相当于是最后一层的 2 倍了

  3. 对任何非空二叉树，若 n0 表示叶子节点的个数，n2 表示度为 2 的非叶子节点个数，那么两者满足关系：n0 = n2 + 1
     这个特性先背下来吧。 叶子节点 = 度数为 2 的节点+1

- 特殊的二叉树

  1. 完美二叉树
     完美二叉树（Perfect Binary Tree）也称为满二叉树（Full Binary Tree），在二叉树中，除了最下一层的叶子节点外，每层节点都有 2 个子节点，这就构成了完美二叉树。
  2. 完全二叉树

  - 除了二叉树最后一层外，其他各层的节点数都达到了最大值
  - 并且，最后一层的叶子节点从左向右是连续存在，只缺失右侧若干叶子节点
  - 完美二叉树是特殊的完全二叉树

- 存储：常见的二叉树存储方式为数组和链表

  1. 使用数组（一维数组）

     - 完全二叉树：使用按从上到下，从左到右的方式存储数据如：
       节点 A B C D E F G H I
       序号 1 2 3 4 5 6 7 8 9
       使用数组存储时，取数据的时候也十分方便：左子节点的序号等于父节点序号 \* 2，右子节点的序号等于父节点序号 \* 2 + 1
     - 非完全二叉树
       非完全二叉树需要转换成完全二叉树才能按照上面的方案存储，转的方式是按照最大层次排列，无自子节点的部分使用空节点，这样会浪费很大的存储空间。
       如果不转成完全二叉树，无法区分是左节点的子节点还是右节点的

  2. 使用链表
     二叉树最常见的存储方式为链表：每一个节点封装成一个 Node，Node 中包含存储的数据、左节点的引用和右节点的引用

### 二叉搜索树(BST)

二叉搜索树（BST，Binary Search Tree），也称为二叉排序树和二叉查找树。

二叉搜索树是一棵二叉树，可以为空。如果不为空，则需要满足以下性质：

- 非空左子树的所有键值小于其根节点的键值
- 非空右子树的所有键值大于其根节点的键值
- 左、右子树本身也都是二叉搜索树

总结：

- 从上往下的左边链路递减，从上往下的右边链路递增
- 这种特点使得二叉搜索树的查询效率非常高，这也就是二叉搜索树中“搜索”的来源
- 二分查找的原理就是二叉搜索树

#### 二叉搜索树的封装

二叉搜索树有四个最基本的属性：

1. 指向节点的根（root）
2. 节点中的键（key）
3. 左指针（left）
4. 右指针（right）

所以，二叉搜索树中除了定义 root 属性外，还应定义一个节点内部类，里面包含每个节点中的 left、right 和 key 三个属性(再增加一个 value 属性保存数据，否则很奇怪)

```
// 节点类
class Node {
  constructor(key,value) {
    this.key = key;
    this.value = value;
    this.left = null;
    this.right = null;
  }
}
```

#### 二叉搜索树的常见操作

- insert(key) 向树中插入一个新的键
- search(key) 在树中查找一个键，如果节点存在，则返回 true；如果不存在，则返回 false
- preOrderTraverse 通过先序遍历方式遍历所有节点
- inOrderTraverse 通过中序遍历方式遍历所有节点
- postOrderTraverse 通过后序遍历方式遍历所有节点
- min 返回树中最小的值/键
- max 返回树中最大的值/键
- remove(key) 从树中移除某个键

### 树的遍历

- 中序遍历
- 先序遍历
- 后序遍历

### 二叉搜索树的删除

### 二叉树的补充

## 图结构

### 图相关概念

### 图的表示

- 邻接矩阵
- 邻接表
- 关联矩阵

### 自定义图

### 图的遍历

- 广度优先搜索
- 深度优先搜索

## 排序 & 搜索

### 简单排序

- 冒泡排序
- 选择排序

### 高级排序

- 希尔排序
- 快速排序

_XMind - Trial Version_
