# 数据结构与算法

## 线性结构

- 线性结构是一个有序数据元素的集合。

- 常用的线性结构有：线性表，栈，队列，双队列，串(一维数组)。

- 常见的非线性结构有：二维数组，多维数组，广义表，树(二叉树等)，图

线性结构的特征：

1. 集合中必存在唯一的一个"第一个元素"；
2. 集合中必存在唯一的一个"最后的元素"；
3. 除最后元素之外，其它数据元素均有唯一的"后继"；
4. 除第一元素之外，其它数据元素均有唯一的"前驱"。

### 数组

JS 已经封装好了数组结构，比较高级。而其他常见语言数组（偏底层）一般有如下特点：

1. 不能存放不同的数据类型
2. 数组容量不会自动改变
   当超出容量时：需要进行扩容，申请一个更大容量的数组，然后将原先数组中的内容复制过去
3. 数组进行中间插入和删除操作性能比较低
   比方说头部插入一个元素，但是因为头部已经有元素了，所以需要先把所有的元素右移一位，再把新插入元素放到首位。效率较低，删除同理
4. 根据下标查找效率很高

### 栈（Stack）

数组是一个线性结构，并且可以在数组的任意位置插入和删除元素。 但是有时候，我们为了实现某些功能，必须对这种任意性加以限制。 栈和队列就是比较常见的受限的线性结构。

栈（stack）是一种运算受限的线性表，它有下特点：

1. LIFO（last in first out）：先进后出，后进先出
2. 其限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。
3. 向一个栈插入新元素又称作进栈、入栈或压栈；从一个栈删除元素又称作出栈或退栈

程序中的栈应用：

1. 函数调用栈：
   假设 A 函数中执行了 B 函数、B 函数中又执行了 C 函数
   那么在执行过程中，A 率先入栈、然后执行到 B 函数，B 函数入栈，然后 C 函数入栈。而 C 函数会优先执行完，率先出栈，然后 B 出栈，最后 A 出栈。

2. 递归：
   递归也是一种栈结构，递归函数第一遍执行，将自己入栈。然后调用自己，继续将自己压入栈中。直到达到结束递归的条件，最后一个入栈的自己执行完，再一个一个出栈。首次执行的函数，最后出栈
   如果到不了结束递归的条件，那么一直往函数调用栈入栈元素，最后导致栈溢出报错

练习：

- 有 6 个元素 6，5，4，3，2，1 按顺序进栈，问下列哪一个不是合法的出栈顺序？
  结题关键，按顺序入栈，不代表一次性全部入栈，可以入栈后，下一个元素还未入栈就出栈了

#####

#### 自定义栈

要封装一个自定义栈，首先要知道栈有哪些常见操作

- push() 添加一个新元素到栈顶位置。
- pop() 移除栈顶的元素，同时返回被移除的元素。
- peek() 返回栈顶的元素，不对栈做任何修改（该方法不会移除栈顶的元素，仅仅返回它）。
- isEmpty() 如果栈里没有任何元素就返回 true，否则返回 false。
- size() 返回栈里的元素个数。这个方法和数组的 length 属性类似。
- toString() 将栈结构的内容以字符串的形式返回。

#### 栈的应用

- 十进制转二进制

1. 整数部分：除 2 取余，反向排列
   将十进制数整数除以 2，取余数，一直除到结果为 1，余数为 0 为止
2. 小数部分：乘 2 取整，正向排列
   将十进制小数乘以 2，取整数部分，小数部分继续乘以 2，知道小数部分为 0
   这个过程中可能永远无法为 0，出现循环，表示无法完全转换，只能保留固定位数，这就是进制转换存在的精度问题

### 队列（queue）

队列（Queue）是一种运算受限的线性表，特点：先进先出。(FIFO：First In First Out)
受限之处：

1. 只允许在表的前端（front）进行删除操作
2. 只允许在表的后端（rear）进行插入操作。

应用场景：排队，比如在电影院，商场，食堂等等

#### 自定义队列

队列的实现和栈一样，有两种方案：

1. 基于数组实现
2. 基于链表实现

队列常见的操作：

1. enqueue(element) 向队列尾部添加一个（或多个）新的项
2. dequeue() 移除队列的第一（即排在队列最前面的）项，并返回被移除的元素
3. front() 返回队列中的第一个元素——最先被添加，也将是最先被移除的元素。队列不做任何变动（不移除元素，只返回元素信息与 Map 类的 peek 方法非常类似）
4. isEmpty() 如果队列中不包含任何元素，返回 true，否则返回 false
5. size() 返回队列包含的元素个数，与数组的 length 属性类似
6. toString() 将队列中的内容，转成字符串形式

#### 优先级队列

#### 队列的应用

队列在程序中的应用：

1. 打印队列：计算机打印多个文件的时候，需要排队打印
2. 线程队列：当开启多线程时，当新开启的线程所需的资源不足时就先放入线程队列，等待 CPU 处理。

### 链表

- 链表原理
- 自定义链表

#### 双向链表

- 单向链表特点

  1. 只能从头遍历到尾或者从尾遍历到头（一般从头到尾）
  2. 链表相连的过程是单向的，实现原理是上一个节点中有指向下一个节点的引用
  3. 单向链表有一个比较明显的缺点：可以轻松到达下一个节点，但回到前一个节点很难，在实际开发中, 经常会遇到需要回到上一个节点的情况

- 双向链表特点
  1. 既可以从头遍历到尾，也可以从尾遍历到头
  2. 链表相连的过程是双向的。实现原理是一个节点既有向前连接的引用，也有一个向后连接的引用
  3. 双向链表可以有效的解决单向链表存在的问题，即回到上一个节点
  4. 双向链表缺点
     每次在插入或删除某个节点时，都需要处理四个引用，而不是两个，实现起来会困难些？
     相对于单向链表，所占内存空间更大一些

但是，相对于双向链表的便利性而言，这些缺点微不足道。所以它在各种语言中的应用比单向链表要多。

- 双向链表结构：

  1. 双向链表不仅有 head 指针指向第一个节点，而且有 tail 指针指向最后一个节点，还有一个 length
  2. 每一个节点由三部分组成：item 储存数据、prev 指向前一个节点、next 指向后一个节点
  3. 双向链表的第一个节点的 prev 指向 null
  4. 双向链表的最后一个节点的 next 指向 null

- 双向链表常见的操作

  1. append(element) 向链表尾部追加一个新元素
  2. insert(position, element) 向链表的指定位置插入一个新元素
  3. getElement(position) 获取指定位置的元素
  4. indexOf(element) 返回元素在链表中的索引。如果链表中没有该元素就返回 -1
  5. update(position, element) 修改指定位置上的元素
  6. removeAt(position) 从链表中的删除指定位置的元素
  7. remove(element) 从链表删除指定的元素
  8. isEmpty() 如果链表中不包含任何元素，返回 trun，如果链表长度大于 0 则返回 false
  9. size() 返回链表包含的元素个数，与数组的 length 属性类似
  10. toString() 由于链表项使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString 方法，让其只输出元素的值
  11. forwardString() 返回反向遍历节点字符串形式，forward 代表从后往前
  12. backwardString() 返回正向遍历的节点的字符串形式，backward 代表从前往后，和 toString 完全相同
  13. getHead() 获取首部元素
  14. getTail() 获取尾部元素

## 集合

几乎每种编程语言中，都有集合结构。集合比较常见的实现方式是哈希表，这里使用 JavaScript 的 Object 进行封装。

### 集合的特点

- 集合通常是由一组无序的、不能重复的元素构成
- 数学中常指的集合中的元素是可以重复的，但是计算机中集合的元素不能重复
- 集合可以看做是特殊的数组：
  1. 特殊之处在于里面的元素没有顺序，也不能重复
  2. 没有顺序意味着不能通过下标值进行访问，不能重复意味着相同的对象在集合中只会存在一份

### 封装集合

ES6 中的 Set 就是一个集合类，这里我们重新封装一个 Set 类，了解集合的底层实现

### 集合常见的操作

1. add(value) 向集合添加一个新的项
2. delete(value) 从集合移除一个值 --教程中是 remove 方法，这里和 ES6 的 Set 类保持一致，有利于记忆
3. has(value) 如果值在集合中，返回 true，否则返回 false
4. clear() 移除集合中的所有项
5. size() 返回集合所包含元素的数量。与数组的 length 属性类似
6. values() 返回一个包含集合中所有值的数组

还有其他的方法，用的不多，这里不做封装。

### 集合间的操作

- 并集（代表合并）：对于给定的两个集合，返回一个包含两个集合中所有元素的新集合
  A∪B = {x|x∈A,或 x∈B}
- 交集（代表相交）：对于给定的两个集合，返回一个包含两个集合中共有元素的新集合
  A∩B= {x|x∈A∧x∈B}
- 差集（代表差值，即相减）：对于给定的两个集合，返回一个包含所有存在于第一个集合且不存在于第二个集合的元素的新集合
  A - B
- 子集：验证一个给定集合是否是另一个集合的子集。集合 A 的任意一个元素都是集合 B 的元素
  A⊆B

## 字典

数组-集合-字典是几乎编程语言都会默认提供的数据类型。ES6 新增了 Map 类型，就是代表字典。

### 字典的特点

- 字典存储的是键值对，主要特点是一一对应。
- 比如保存一个人的信息
  1. 数组形式：[19，"Tom", 1.65]，可通过下标值取出信息。
  2. 字典形式：{"age": 19, "name": "Tom", "height": 165}，可以通过 key 取出 value
- 此外，在字典中 key 是不能重复且无序的，而 Value 可以重复

有些编程语言中称这种映射关系为字典，如 Swift 中的 Dictonary，Python 中的 dict
有些编程语言中称这种映射关系为 Map，比如 Java 中的 HashMap 和 TreeMap 等

### 字典的常见操作

1. set(key,value) 向字典中添加新元素
2. remove(key) 通过使用键值来从字典中移除键值对应的数据值
3. has(key) 如果某个键值存在于这个字典中，则返回 true，反之则返回 false
4. get(key) 通过键值查找特定的数值并返回
5. clear() 将这个字典中的所有元素全部删除
6. size() 返回字典所包含元素的数量。与数组的 length 属性类似
7. keys() 将字典所包含的所有键名以数组形式返回
8. values() 将字典所包含的所有数值以数组形式返回

## 哈希表

### 哈希表理论

#### 哈希表介绍

哈希表是一种非常重要的数据结构，几乎所有的编程语言都直接或者间接应用这种数据结构

- 哈希表通常是基于数组实现的，但是相对于数组，它存在更多优势：

  1.  哈希表可以提供非常快速的 插入-删除-查找 操作
  2.  无论多少数据，插入和删除值都只需接近常量的时间，即 O(1) 的时间复杂度。实际上，只需要几个机器指令 即可完成
  3.  哈希表的速度比树还要快，基本可以瞬间查找到想要的元素
  4.  哈希表相对于树来说编码要简单得多

- 哈希表同样存在不足之处：
  1.  哈希表中的数据是没有顺序的，所以不能以一种固定的方式（比如从小到大 ）来遍历其中的元素
  2.  通常情况下，哈希表中的 key 是不允许重复的，不能放置相同的 key，用于保存不同的元素

哈希表无序且不能重复的特点，所以集合和字典都是基于哈希表实现

- 哈希表是什么？
  1.  哈希表并不好理解，不像数组、链表和树等可通过图形的形式表示其结构和原理
  2.  哈希表的结构就是数组，但它神奇之处在于对下标值的一种变换，这种变换我们可以称之为哈希函数，通过哈希函数可以获取 HashCode

接下来就通过几个案例了解下哈希表

- 案例一：公司想要存储 1000 个人的信息，每一个工号对应一个员工的信息

  1.  数组
      当中间有人离职和入职时，插入新员工和删除旧员工信息的效率较低。
      通过名字查找对应人员的效率较低（遍历）。
      通过工号查找效率较高（工号从 0 开始++），即为下标。通过下标查找
  2.  链表
      员工信息的应用场景大多还是在查找。链表查找效率很低，需要从头或者从尾遍历
      链表的优势在于插入和删除较快，但是员工的变动并不会太频繁
  3.  哈希表
      数组通过工号查找效率较高。通过名字查找则不行
      哈希函数就是将某个 key 和索引值对应起来，这样通过名称我就能知道工号，再通过工号查找效率就很高了

- 案例二：存储联系人和对应的电话号码

  1. 数组 or 链表：
     还是同样的问题，一般查找都是根据联系人姓名查找电话号码。数组或者链表的形式，查找时就需要遍历，当数据量很大时效率低
  2. 哈希表
     基于数组，但是在联系人姓名和下标之间建议对应关系。即将字符串转成下标值的方法（哈希函数）

- 案例三：50000 个单词的存储
  和案例二类似，通过单词本身查找时需要遍历。最好是通过哈希函数，通过单词查找到下标，再通过下标查找
  效率大大提高

案例总结：哈希表最后还是基于数组来实现的，只不过哈希表能够通过哈希函数把字符串转化为对应的下标值，建立字符串和下标值的映射关系。

- 单词转数字

#### 认识哈希化

#### 地址的冲突

##### 链地址法

##### 开放地址法

#### 哈希化效率

### 自定义哈希表

- 哈希函数
- 哈希表的实现
- 哈希表扩容
- 容量质数

## 树结构

### 树相关概念

- 树的基本概念
- 二叉树的概念

### 二叉搜索树

- 二叉搜索树的概念

### 树的遍历

- 中序遍历
- 先序遍历
- 后序遍历

### 二叉搜索树的删除

### 二叉树的补充

## 图结构

### 图相关概念

### 图的表示

- 邻接矩阵
- 邻接表
- 关联矩阵

### 自定义图

### 图的遍历

- 广度优先搜索
- 深度优先搜索

## 排序 & 搜索

### 简单排序

- 冒泡排序
- 选择排序

### 高级排序

- 希尔排序
- 快速排序

_XMind - Trial Version_
